module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Cube.js":
/*!*********************!*\
  !*** ./src/Cube.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Cube\n *\n * @classdesc\n * Creates a new Cube object with the bottom-back corner specified by the x, y and z parameters, with the specified breadth (widthX), depth (widthY) and height parameters. If you call this function without parameters, a Cube with x, y, z, breadth, depth and height properties set to 0 is created.\n */\nvar Cube = function () {\n  /**\n   * @constructor\n   * @param {number} x - The x coordinate of the bottom-back corner of the Cube.\n   * @param {number} y - The y coordinate of the bottom-back corner of the Cube.\n   * @param {number} z - The z coordinate of the bottom-back corner of the Cube.\n   * @param {number} widthX - The X axis width (breadth) of the Cube. Should always be either zero or a positive value.\n   * @param {number} widthY - The Y axis width (depth) of the Cube. Should always be either zero or a positive value.\n   * @param {number} height - The Z axis height of the Cube. Should always be either zero or a positive value.\n   * @return {Cube} This Cube object.\n   */\n  function Cube() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var widthX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var widthY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var height = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Cube);\n\n    /**\n     * @property {number} x - The x coordinate of the bottom-back corner of the Cube.\n     */\n    this.x = x;\n\n    /**\n     * @property {number} y - The y coordinate of the bottom-back corner of the Cube.\n     */\n    this.y = y;\n\n    /**\n     * @property {number} z - The z coordinate of the bottom-back corner of the Cube.\n     */\n    this.z = z;\n\n    /**\n     * @property {number} widthX - The X axis width (breadth) of the Cube. This value should never be set to a negative.\n     */\n    this.widthX = widthX;\n\n    /**\n     * @property {number} widthY - The Y axis width (depth) of the Cube. This value should never be set to a negative.\n     */\n    this.widthY = widthY;\n\n    /**\n     * @property {number} height - The Z axis height of the Cube. This value should never be set to a negative.\n     */\n    this.height = height;\n\n    /**\n     * @property {Array.<Point3>} _corners - The 8 corners of the Cube.\n     * @private\n     */\n    this._corners = [new _Point2.default(this.x, this.y, this.z), new _Point2.default(this.x, this.y, this.z + this.height), new _Point2.default(this.x, this.y + this.widthY, this.z), new _Point2.default(this.x, this.y + this.widthY, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y, this.z), new _Point2.default(this.x + this.widthX, this.y, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z + this.height)];\n  }\n\n  /**\n   * Sets the members of Cube to the specified values.\n   * @method Cube#setTo\n   * @param {number} x - The x coordinate of the bottom-back corner of the Cube.\n   * @param {number} y - The y coordinate of the bottom-back corner of the Cube.\n   * @param {number} z - The z coordinate of the bottom-back corner of the Cube.\n   * @param {number} widthX - The X axis width (breadth) of the Cube. This value should never be set to a negative.\n   * @param {number} widthY - The Y axis width (depth) of the Cube. This value should never be set to a negative.\n   * @param {number} height - The Z axis height of the Cube. This value should never be set to a negative.\n   * @return {Cube} This Cube object\n   */\n\n\n  _createClass(Cube, [{\n    key: 'setTo',\n    value: function setTo(x, y, z, widthX, widthY, height) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.widthX = widthX;\n      this.widthY = widthY;\n      this.height = height;\n\n      return this;\n    }\n\n    /**\n     * Copies the x, y, z, widthX, widthY and height properties from any given object to this Cube.\n     * @method Cube#copyFrom\n     * @param {any} source - The object to copy from.\n     * @return {Cube} This Cube object.\n     */\n\n  }, {\n    key: 'copyFrom',\n    value: function copyFrom(source) {\n      this.setTo(source.x, source.y, source.z, source.widthX, source.widthY, source.height);\n    }\n\n    /**\n     * Copies the x, y, z, widthX, widthY and height properties from this Cube to any given object.\n     * @method Cube#copyTo\n     * @param {any} dest - The object to copy to.\n     * @return {Cube} This Cube object.\n     */\n\n  }, {\n    key: 'copyTo',\n    value: function copyTo(dest) {\n      dest.x = this.x;\n      dest.y = this.y;\n      dest.z = this.z;\n      dest.widthX = this.widthX;\n      dest.widthY = this.widthY;\n      dest.height = this.height;\n\n      return dest;\n    }\n\n    /**\n     * The size of the Cube object, expressed as a Point3 object with the values of the widthX, widthY and height properties.\n     * @method Cube#size\n     * @param {Point3} [output] - Optional Point3 object. If given the values will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @return {Point3} The size of the Cube object.\n     */\n\n  }, {\n    key: 'size',\n    value: function size(output) {\n      return Cube.size(this, output);\n    }\n\n    /**\n     * Determines whether the specified coordinates are contained within the region defined by this Cube object.\n     * @method Cube#contains\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @param {number} y - The z coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(x, y, z) {\n      return Cube.contains(this, x, y, z);\n    }\n\n    /**\n     * Determines whether the specified X and Y coordinates are contained within the region defined by this Cube object.\n     * @method Cube#containsXY\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @return {boolean} A value of true if this Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsXY',\n    value: function containsXY(x, y) {\n      return Cube.containsXY(this, x, y);\n    }\n\n    /**\n     * Returns a new Cube object with the same values for the x, y, z, widthX, widthY and height properties as the original Cube object.\n     * @method Cube#clone\n     * @param {Cube} [output] - Optional Cube object. If given the values will be set into the object, otherwise a brand new Cube object will be created and returned.\n     * @return {Cube}\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone(output) {\n      return Cube.clone(this, output);\n    }\n\n    /**\n     * Determines whether the two Cubes intersect with each other.\n     * This method checks the x, y, z, widthX, widthY, and height properties of the Cubes.\n     * @method Cube#intersects\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the specified object intersects with this Cube object; otherwise false.\n     */\n\n  }, {\n    key: 'intersects',\n    value: function intersects(b) {\n      return Cube.intersects(this, b);\n    }\n\n    /**\n     * Updates and returns an Array of eight Point3 objects containing the corners of this Cube.\n     * @method Cube#getCorners\n     * @return {Array.<Point3>} The corners of this Cube expressed as an Array of eight Point3 objects.\n     */\n\n  }, {\n    key: 'getCorners',\n    value: function getCorners() {\n      this._corners[0].setTo(this.x, this.y, this.z);\n      this._corners[1].setTo(this.x, this.y, this.z + this.height);\n      this._corners[2].setTo(this.x, this.y + this.widthY, this.z);\n      this._corners[3].setTo(this.x, this.y + this.widthY, this.z + this.height);\n      this._corners[4].setTo(this.x + this.widthX, this.y, this.z);\n      this._corners[5].setTo(this.x + this.widthX, this.y, this.z + this.height);\n      this._corners[6].setTo(this.x + this.widthX, this.y + this.widthY, this.z);\n      this._corners[7].setTo(this.x + this.widthX, this.y + this.widthY, this.z + this.height);\n\n      return this._corners;\n    }\n\n    /**\n     * Returns a string representation of this object.\n     * @method Cube#toString\n     * @return {string} A string representation of the instance.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[{Cube (x=' + this.x + ' y=' + this.y + ' z=' + this.z + ' widthX=' + this.widthX + ' widthY=' + this.widthY + ' height=' + this.height + ' empty=' + this.empty + ')}]';\n    }\n\n    /**\n     * @name Cube#halfWidthX\n     * @property {number} halfWidthX - Half of the widthX of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfWidthX',\n    get: function get() {\n      return Math.round(this.widthX * 0.5);\n    }\n\n    /**\n     * @name Cube#halfWidthY\n     * @property {number} halfWidthY - Half of the widthY of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfWidthY',\n    get: function get() {\n      return Math.round(this.widthY * 0.5);\n    }\n\n    /**\n     * @name Cube#halfHeight\n     * @property {number} halfHeight - Half of the height of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfHeight',\n    get: function get() {\n      return Math.round(this.height * 0.5);\n    }\n\n    /**\n     * The z coordinate of the bottom of the Cube. Changing the bottom property of a Cube object has no effect on the x, y, widthX and widthY properties.\n     * However it does affect the height property, whereas changing the z value does not affect the height property.\n     * @name Cube#bottom\n     * @property {number} bottom - The z coordinate of the bottom of the Cube.\n     */\n\n  }, {\n    key: 'bottom',\n    get: function get() {\n      return this.z;\n    },\n    set: function set(value) {\n      if (value >= this.top) {\n        this.height = 0;\n      } else {\n        this.height = this.top - value;\n      }\n      this.z = value;\n    }\n\n    /**\n     * The sum of the z and height properties. Changing the top property of a Cube object has no effect on the x, y, z, widthX and widthY properties, but does change the height property.\n     * @name Cube#top\n     * @property {number} top - The sum of the z and height properties.\n     */\n\n  }, {\n    key: 'top',\n    get: function get() {\n      return this.z + this.height;\n    },\n    set: function set(value) {\n      if (value <= this.z) {\n        this.height = 0;\n      } else {\n        this.height = value - this.z;\n      }\n    }\n\n    /**\n     * The x coordinate of the back of the Cube. Changing the backX property of a Cube object has no effect on the y, z, widthY and height properties. However it does affect the widthX property, whereas changing the x value does not affect the width property.\n     * @name Cube#backX\n     * @property {number} backX - The x coordinate of the left of the Cube.\n     */\n\n  }, {\n    key: 'backX',\n    get: function get() {\n      return this.x;\n    },\n    set: function set(value) {\n      if (value >= this.frontX) {\n        this.widthX = 0;\n      } else {\n        this.widthX = this.frontX - value;\n      }\n      this.x = value;\n    }\n\n    /**\n     * The y coordinate of the back of the Cube. Changing the backY property of a Cube object has no effect on the x, z, widthX and height properties. However it does affect the widthY property, whereas changing the y value does not affect the width property.\n     * @name Cube#backY\n     * @property {number} backY - The x coordinate of the left of the Cube.\n     */\n\n  }, {\n    key: 'backY',\n    get: function get() {\n      return this.y;\n    },\n    set: function set(value) {\n      if (value >= this.frontY) {\n        this.widthY = 0;\n      } else {\n        this.widthY = this.frontY - value;\n      }\n      this.y = value;\n    }\n\n    /**\n     * The sum of the x and widthX properties. Changing the frontX property of a Cube object has no effect on the x, y, z, widthY and height properties, however it does affect the widthX property.\n     * @name Cube#frontX\n     * @property {number} frontX - The sum of the x and widthX properties.\n     */\n\n  }, {\n    key: 'frontX',\n    get: function get() {\n      return this.x + this.widthX;\n    },\n    set: function set(value) {\n      if (value <= this.x) {\n        this.widthX = 0;\n      } else {\n        this.widthX = value - this.x;\n      }\n    }\n\n    /**\n     * The sum of the y and widthY properties. Changing the frontY property of a Cube object has no effect on the x, y, z, widthX and height properties, however it does affect the widthY property.\n     * @name Cube#frontY\n     * @property {number} frontY - The sum of the y and widthY properties.\n     */\n\n  }, {\n    key: 'frontY',\n    get: function get() {\n      return this.y + this.widthY;\n    },\n    set: function set(value) {\n      if (value <= this.y) {\n        this.widthY = 0;\n      } else {\n        this.widthY = value - this.y;\n      }\n    }\n\n    /**\n     * The volume of the Cube derived from widthX * widthY * height.\n     * @name Cube#volume\n     * @property {number} volume - The volume of the Cube derived from widthX * widthY * height.\n     * @readonly\n     */\n\n  }, {\n    key: 'volume',\n    get: function get() {\n      return this.widthX * this.widthY * this.height;\n    }\n\n    /**\n     * The x coordinate of the center of the Cube.\n     * @name Cube#centerX\n     * @property {number} centerX - The x coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerX',\n    get: function get() {\n      return this.x + this.halfWidthX;\n    },\n    set: function set(value) {\n      this.x = value - this.halfWidthX;\n    }\n\n    /**\n     * The y coordinate of the center of the Cube.\n     * @name Cube#centerY\n     * @property {number} centerY - The y coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerY',\n    get: function get() {\n      return this.y + this.halfWidthY;\n    },\n    set: function set(value) {\n      this.y = value - this.halfWidthY;\n    }\n\n    /**\n     * The z coordinate of the center of the Cube.\n     * @name Cube#centerZ\n     * @property {number} centerZ - The z coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerZ',\n    get: function get() {\n      return this.z + this.halfHeight;\n    },\n    set: function set(value) {\n      this.z = value - this.halfHeight;\n    }\n\n    /**\n     * A random value between the frontX and backX values (inclusive) of the Cube.\n     *\n     * @name Cube#randomX\n     * @property {number} randomX - A random value between the frontX and backX values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomX',\n    get: function get() {\n      return this.x + Math.random() * this.widthX;\n    }\n\n    /**\n     * A random value between the frontY and backY values (inclusive) of the Cube.\n     *\n     * @name Cube#randomY\n     * @property {number} randomY - A random value between the frontY and backY values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomY',\n    get: function get() {\n      return this.y + Math.random() * this.widthY;\n    }\n\n    /**\n     * A random value between the bottom and top values (inclusive) of the Cube.\n     *\n     * @name Cube#randomZ\n     * @property {number} randomZ - A random value between the bottom and top values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomZ',\n    get: function get() {\n      return this.z + Math.random() * this.height;\n    }\n\n    /**\n     * Determines whether or not this Cube object is empty. A Cube object is empty if its widthX, widthY or height is less than or equal to 0.\n     * If set to true then all of the Cube properties are set to 0.\n     * @name Cube#empty\n     * @property {boolean} empty - Gets or sets the Cube's empty state.\n     */\n\n  }, {\n    key: 'empty',\n    get: function get() {\n      return !this.widthX || !this.widthY || !this.height;\n    },\n    set: function set(value) {\n      if (value === true) {\n        this.setTo(0, 0, 0, 0, 0, 0);\n      }\n    }\n\n    /**\n     * The size of the Cube object, expressed as a Point3 object with the values of the widthX, widthY and height properties.\n     * @method Cube.size\n     * @param {Cube} a - The Cube object.\n     * @param {Point3} [output] - Optional Point3 object. If given the values will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @return {Point3} The size of the Cube object\n     */\n\n  }], [{\n    key: 'size',\n    value: function size(a, output) {\n      if (typeof output === 'undefined' || output === null) {\n        output = new _Point2.default(a.widthX, a.widthY, a.height);\n      } else {\n        output.setTo(a.widthX, a.widthY, a.height);\n      }\n\n      return output;\n    }\n\n    /**\n     * Returns a new Cube object with the same values for the x, y, z, widthX, widthY, and height properties as the original Cube object.\n     * @method Cube.clone\n     * @param {Cube} a - The Cube object.\n     * @param {Cube} [output] - Optional Cube object. If given the values will be set into the object, otherwise a brand new Cube object will be created and returned.\n     * @return {Cube}\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone(a, output) {\n      if (typeof output === 'undefined' || output === null) {\n        output = new Cube(a.x, a.y, a.z, a.widthX, a.widthY, a.height);\n      } else {\n        output.setTo(a.x, a.y, a.z, a.widthX, a.widthY, a.height);\n      }\n\n      return output;\n    }\n\n    /**\n     * Determines whether the specified coordinates are contained within the region defined by this Cube object.\n     * @method Cube.contains\n     * @param {Cube} a - The Cube object.\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @param {number} z - The z coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(a, x, y, z) {\n      if (a.widthX <= 0 || a.widthY <= 0 || a.height <= 0) {\n        return false;\n      }\n\n      return x >= a.x && x <= a.frontX && y >= a.y && y <= a.frontY && z >= a.z && z <= a.top;\n    }\n\n    /**\n     * Determines whether the specified X and Y coordinates are contained within the region defined by this Cube object.\n     * @method Cube.containsXY\n     * @param {Cube} a - The Cube object.\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsXY',\n    value: function containsXY(a, x, y) {\n      if (a.widthX <= 0 || a.widthY <= 0) {\n        return false;\n      }\n\n      return x >= a.x && x <= a.frontX && y >= a.y && y <= a.frontY;\n    }\n\n    /**\n     * Determines whether the specified point is contained within the cubic region defined by this Cube object. This method is similar to the Cube.contains() method, except that it takes a Point3 object as a parameter.\n     * @method Cube.containsPoint3\n     * @param {Cube} a - The Cube object.\n     * @param {Point3} point3 - The Point3 object being checked. Can be Point3 or any object with .x, .y and .z values.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsPoint3',\n    value: function containsPoint3(a, point3) {\n      return Cube.contains(a, point3.x, point3.y, point3.z);\n    }\n\n    /**\n     * Determines whether the first Cube object is fully contained within the second Cube object.\n     * A Cube object is said to contain another if the second Cube object falls entirely within the boundaries of the first.\n     * @method Cube.containsCube\n     * @param {Cube} a - The first Cube object.\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsCube',\n    value: function containsCube(a, b) {\n      //  If the given cube has a larger volume than this one then it can never contain it\n      if (a.volume > b.volume) {\n        return false;\n      }\n\n      return a.x >= b.x && a.y >= b.y && a.z >= b.z && a.frontX <= b.frontX && a.frontY <= b.frontY && a.top <= b.top;\n    }\n\n    /**\n     * Determines whether the two Cubes intersect with each other.\n     * This method checks the x, y, z, widthX, widthY, and height properties of the Cubes.\n     * @method Cube.intersects\n     * @param {Cube} a - The first Cube object.\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the specified object intersects with this Cube object; otherwise false.\n     */\n\n  }, {\n    key: 'intersects',\n    value: function intersects(a, b) {\n      if (a.widthX <= 0 || a.widthY <= 0 || a.height <= 0 || b.widthX <= 0 || b.widthY <= 0 || b.height <= 0) {\n        return false;\n      }\n      return !(a.frontX < b.x || a.frontY < b.y || a.x > b.frontX || a.y > b.frontY || a.z > b.top || a.top < b.z);\n    }\n  }]);\n\n  return Cube;\n}();\n\nexports.default = Cube;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Cube.js?");

/***/ }),

/***/ "./src/IsoPlugin.js":
/*!**************************!*\
  !*** ./src/IsoPlugin.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsoSprite = exports.IsoPhysics = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * The MIT License (MIT)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Copyright (c) 2015 Lewis Lane\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Permission is hereby granted, free of charge, to any person obtaining a copy\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * of this software and associated documentation files (the \"Software\"), to deal\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * in the Software without restriction, including without limitation the rights\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * copies of the Software, and to permit persons to whom the Software is\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * furnished to do so, subject to the following conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * The above copyright notice and this permission notice shall be included in\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n/**\n * @author       Lewis Lane <lew@rotates.org>\n * @copyright    2015 Lewis Lane (Rotates.org)\n * @license      {@link http://opensource.org/licenses/MIT|MIT License}\n */\n\nvar _IsoPhysics = __webpack_require__(/*! ./physics/IsoPhysics */ \"./src/physics/IsoPhysics.js\");\n\nObject.defineProperty(exports, 'IsoPhysics', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_IsoPhysics).default;\n  }\n});\n\nvar _IsoSprite = __webpack_require__(/*! ./IsoSprite */ \"./src/IsoSprite.js\");\n\nObject.defineProperty(exports, 'IsoSprite', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_IsoSprite).default;\n  }\n});\n\nvar _Projector = __webpack_require__(/*! ./Projector */ \"./src/Projector.js\");\n\nvar _Projector2 = _interopRequireDefault(_Projector);\n\nvar _IsoSprite2 = _interopRequireDefault(_IsoSprite);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//  Type consts\n\n/**\n * @class IsometricPlugin\n * \n * @classdesc\n * Isometric is a comprehensive axonometric plugin for Phaser which provides an API for handling axonometric projection of assets in 3D space to the screen.\n * The goal has been to mimic as closely as possible the existing APIs provided by Phaser for standard orthogonal 2D projection, but add a third dimension.\n * Also included is an Arcade-based 3D AABB physics engine, which again is closely equivalent in functionality and its API.\n */\nvar IsoPlugin = function () {\n  /**\n   * @constructor\n   * @param {Phaser.Scene} scene The current scene instance\n   */\n  function IsoPlugin(scene) {\n    _classCallCheck(this, IsoPlugin);\n\n    this.scene = scene;\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted) {\n      scene.sys.events.once('boot', this.boot, this);\n    }\n\n    this.projector = new _Projector2.default(scene, scene.isometricType);\n\n    /**\n     * Create a new IsoSprite with specific position and sprite sheet key.\n     *\n     * @method Phaser.GameObjectFactory#isoSprite\n     * @param {number} x - X position of the new IsoSprite.\n     * @param {number} y - Y position of the new IsoSprite.\n     * @param {number} y - Z position of the new IsoSprite.\n     * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n     * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n     * @returns {IsoSprite} the newly created IsoSprite object.\n     */\n\n    Phaser.GameObjects.GameObjectCreator.register('isoSprite', function (x, y, z, key, frame) {\n      return new _IsoSprite2.default(this.scene, x, y, z, key, frame);\n    });\n\n    /**\n     * Create a new IsoSprite with specific position and sprite sheet key.\n     *\n     * @method Phaser.GameObjectFactory#isoSprite\n     * @param {number} x - X position of the new IsoSprite.\n     * @param {number} y - Y position of the new IsoSprite.\n     * @param {number} y - Z position of the new IsoSprite.\n     * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n     * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n     * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n     * @returns {IsoSprite} the newly created IsoSprite object.\n     */\n    Phaser.GameObjects.GameObjectFactory.register('isoSprite', function (x, y, z, key, group) {\n      var frame = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n      var sprite = new _IsoSprite2.default(this.scene, x, y, z, key, frame);\n\n      if (typeof group === 'undefined') {\n        this.displayList.add(sprite);\n        this.updateList.add(sprite);\n      } else {\n        group.add(sprite, true);\n      }\n\n      return sprite;\n    });\n  }\n\n  _createClass(IsoPlugin, [{\n    key: 'boot',\n    value: function boot() {}\n  }], [{\n    key: 'register',\n    value: function register(PluginManager) {\n      PluginManager.register('IsoPlugin', IsoPlugin, 'isoPlugin');\n    }\n  }]);\n\n  return IsoPlugin;\n}();\n\nexports.default = IsoPlugin;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/IsoPlugin.js?");

/***/ }),

/***/ "./src/IsoSprite.js":
/*!**************************!*\
  !*** ./src/IsoSprite.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ISOSPRITE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Cube = __webpack_require__(/*! ./Cube */ \"./src/Cube.js\");\n\nvar _Cube2 = _interopRequireDefault(_Cube);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ISOSPRITE = exports.ISOSPRITE = 'IsoSprite';\nvar Sprite = Phaser.GameObjects.Sprite;\n\n/**\n* @class IsoSprite\n*\n* @classdesc\n* Create a new `IsoSprite` object. IsoSprites are extended versions of standard Sprites that are suitable for axonometric positioning.\n*\n* IsoSprites are simply Sprites that have three new position properties (isoX, isoY and isoZ) and ask the instance of Projector what their position should be in a 2D scene whenever these properties are changed.\n* The IsoSprites retain their 2D position property to prevent any problems and allow you to interact with them as you would a normal Sprite. The upside of this simplicity is that things should behave predictably for those already used to Phaser.\n*/\n\nvar IsoSprite = function (_Sprite) {\n  _inherits(IsoSprite, _Sprite);\n\n  /**\n   * @constructor\n   * @extends Phaser.GameObjects.Sprite\n   * @param {Phaser.Scene} scene - A reference to the current scene.\n   * @param {number} x - The x coordinate (in 3D space) to position the IsoSprite at.\n   * @param {number} y - The y coordinate (in 3D space) to position the IsoSprite at.\n   * @param {number} z - The z coordinate (in 3D space) to position the IsoSprite at.\n   * @param {string|Phaser.RenderTexture|Phaser.BitmapData} key - This is the image or texture used by the IsoSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this IsoSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n   */\n  function IsoSprite(scene, x, y, z, texture, frame) {\n    _classCallCheck(this, IsoSprite);\n\n    /**\n     * @property {number} type - The const type of this object.\n     * @readonly\n     */\n    var _this = _possibleConstructorReturn(this, (IsoSprite.__proto__ || Object.getPrototypeOf(IsoSprite)).call(this, scene, x, y, texture, frame));\n\n    _this.type = ISOSPRITE;\n\n    /**\n     * @property {Point3} _isoPosition - Internal 3D position.\n     * @private\n     */\n    _this._isoPosition = new _Point2.default(x, y, z);\n\n    /**\n     * @property {number} snap - Snap this IsoSprite's position to the specified value; handy for keeping pixel art snapped to whole pixels.\n     * @default\n     */\n    _this.snap = 0;\n\n    /**\n     * @property {boolean} _isoPositionChanged - Internal invalidation control for positioning.\n     * @readonly\n     * @private\n     */\n    _this._isoPositionChanged = true;\n\n    /**\n     * @property {boolean} _isoBoundsChanged - Internal invalidation control for isometric bounds.\n     * @readonly\n     * @private\n     */\n    _this._isoBoundsChanged = true;\n\n    _this._project();\n\n    /**\n     * @property {Cube} _isoBounds - Internal derived 3D bounds.\n     * @private\n     */\n    _this._isoBounds = _this.resetIsoBounds();\n    return _this;\n  }\n\n  /**\n   * The axonometric position of the IsoSprite on the x axis. Increasing the x coordinate will move the object down and to the right on the screen.\n   *\n   * @name IsoSprite#isoX\n   * @property {number} isoX - The axonometric position of the IsoSprite on the x axis.\n   */\n\n\n  _createClass(IsoSprite, [{\n    key: '_project',\n\n\n    /**\n     * Internal function that performs the axonometric projection from 3D to 2D space.\n     * @method Phaser.Plugin.Isometric.IsoSprite#_project\n     * @memberof Phaser.Plugin.Isometric.IsoSprite\n     * @private\n     */\n    value: function _project() {\n      if (this._isoPositionChanged) {\n        var pluginKey = this.scene.sys.settings.map.isoPlugin;\n        var sceneProjector = this.scene[pluginKey].projector;\n\n        var _sceneProjector$proje = sceneProjector.project(this._isoPosition),\n            x = _sceneProjector$proje.x,\n            y = _sceneProjector$proje.y;\n\n        this.x = x;\n        this.y = y;\n        this.depth = this._isoPosition.x + this._isoPosition.y + this._isoPosition.z * 1.25;\n\n        if (this.snap > 0) {\n          this.x = Phaser.Math.snapTo(this.x, this.snap);\n          this.y = Phaser.Math.snapTo(this.y, this.snap);\n        }\n\n        this._isoPositionChanged = this._isoBoundsChanged = true;\n      }\n    }\n\n    /**\n     * Internal function called by the World update cycle.\n     *\n     * @method IsoSprite#preUpdate\n     * @memberof IsoSprite\n     */\n\n  }, {\n    key: 'preUpdate',\n    value: function preUpdate(time, delta) {\n      Sprite.prototype.preUpdate.call(this, time, delta);\n\n      this._project();\n    }\n  }, {\n    key: 'resetIsoBounds',\n    value: function resetIsoBounds() {\n      if (typeof this._isoBounds === 'undefined') {\n        this._isoBounds = new _Cube2.default();\n      }\n\n      var asx = Math.abs(this.scaleX);\n      var asy = Math.abs(this.scaleY);\n\n      this._isoBounds.widthX = Math.round(Math.abs(this.width) * 0.5) * asx;\n      this._isoBounds.widthY = Math.round(Math.abs(this.width) * 0.5) * asx;\n      this._isoBounds.height = Math.round(Math.abs(this.height) - Math.abs(this.width) * 0.5) * asy;\n\n      this._isoBounds.x = this.isoX + this._isoBounds.widthX * -this.originX + this._isoBounds.widthX * 0.5;\n      this._isoBounds.y = this.isoY + this._isoBounds.widthY * this.originX - this._isoBounds.widthY * 0.5;\n      this._isoBounds.z = this.isoZ - Math.abs(this.height) * (1 - this.originY) + Math.abs(this.width * 0.5);\n\n      return this._isoBounds;\n    }\n  }, {\n    key: 'isoX',\n    get: function get() {\n      return this._isoPosition.x;\n    },\n    set: function set(value) {\n      this._isoPosition.x = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * The axonometric position of the IsoSprite on the y axis. Increasing the y coordinate will move the object down and to the left on the screen.\n     *\n     * @name IsoSprite#isoY\n     * @property {number} isoY - The axonometric position of the IsoSprite on the y axis.\n     */\n\n  }, {\n    key: 'isoY',\n    get: function get() {\n      return this._isoPosition.y;\n    },\n    set: function set(value) {\n      this._isoPosition.y = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * The axonometric position of the IsoSprite on the z axis. Increasing the z coordinate will move the object directly upwards on the screen.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoZ\n     * @property {number} isoZ - The axonometric position of the IsoSprite on the z axis.\n     */\n\n  }, {\n    key: 'isoZ',\n    get: function get() {\n      return this._isoPosition.z;\n    },\n    set: function set(value) {\n      this._isoPosition.z = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * A Point3 object representing the axonometric position of the IsoSprite.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoPosition\n     * @property {Point3} isoPosition - The axonometric position of the IsoSprite.\n     * @readonly\n     */\n\n  }, {\n    key: 'isoPosition',\n    get: function get() {\n      return this._isoPosition;\n    }\n\n    /**\n     * A Cube object representing the derived boundsof the IsoSprite.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoBounds\n     * @property {Point3} isoBounds - The derived 3D bounds of the IsoSprite.\n     * @readonly\n     */\n\n  }, {\n    key: 'isoBounds',\n    get: function get() {\n      if (this._isoBoundsChanged || !this._isoBounds) {\n        this.resetIsoBounds();\n        this._isoBoundsChanged = false;\n      }\n\n      return this._isoBounds;\n    }\n  }]);\n\n  return IsoSprite;\n}(Sprite);\n\n// Phaser.Utils.Debug.prototype.isoSprite = function (sprite, color, filled) {\n//\n//   if (!sprite.isoBounds) {\n//     return;\n//   }\n//\n//   if (typeof filled === 'undefined') {\n//     filled = true;\n//   }\n//\n//   color = color || 'rgba(0,255,0,0.4)';\n//\n//\n//   var points = [],\n//     corners = sprite.isoBounds.getCorners();\n//\n//   var posX = -sprite.game.camera.x;\n//   var posY = -sprite.game.camera.y;\n//\n//   this.start();\n//\n//   if (filled) {\n//     points = [corners[1], corners[3], corners[2], corners[6], corners[4], corners[5], corners[1]];\n//\n//     points = points.map(function (p) {\n//       var newPos = sprite.game.iso.project(p);\n//       newPos.x += posX;\n//       newPos.y += posY;\n//       return newPos;\n//     });\n//     this.context.beginPath();\n//     this.context.fillStyle = color;\n//     this.context.moveTo(points[0].x, points[0].y);\n//\n//     for (var i = 1; i < points.length; i++) {\n//       this.context.lineTo(points[i].x, points[i].y);\n//     }\n//     this.context.fill();\n//   } else {\n//     points = corners.slice(0, corners.length);\n//     points = points.map(function (p) {\n//       var newPos = sprite.game.iso.project(p);\n//       newPos.x += posX;\n//       newPos.y += posY;\n//       return newPos;\n//     });\n//\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.beginPath();\n//     this.context.strokeStyle = color;\n//\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.moveTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.moveTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.stroke();\n//     this.context.closePath();\n//   }\n//\n//   this.stop();\n//\n// };\n\n\nexports.default = IsoSprite;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/IsoSprite.js?");

/***/ }),

/***/ "./src/Octree.js":
/*!***********************!*\
  !*** ./src/Octree.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Cube = __webpack_require__(/*! ./Cube */ \"./src/Cube.js\");\n\nvar _Cube2 = _interopRequireDefault(_Cube);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Octree\n *\n * @classdesc A Octree implementation based on Phaser.QuadTree.\n * Original version at https://github.com/timohausmann/quadtree-js/\n */\nvar Octree = function () {\n  /**\n   * @constructor\n   * @param {number} x - The bottom-back coordinate of the octree.\n   * @param {number} y - The bottom-back coordinate of the octree.\n   * @param {number} z - The bottom-back coordinate of the octree.\n   * @param {number} widthX - The width X (breadth) of the octree.\n   * @param {number} widthY - The width Y (depth) of the octree.\n   * @param {number} height - The height (Z) of the octree.\n   * @param {number} [maxObjects=10] - The maximum number of objects per node.\n   * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n   * @param {number} [level=0] - Which level is this?\n   */\n  function Octree(x, y, z, widthX, widthY, height, maxObjects, maxLevels, level) {\n    _classCallCheck(this, Octree);\n\n    /**\n     * @property {number} maxObjects - The maximum number of objects per node.\n     * @default\n     */\n    this.maxObjects = 10;\n\n    /**\n     * @property {number} maxLevels - The maximum number of levels to break down to.\n     * @default\n     */\n    this.maxLevels = 4;\n\n    /**\n     * @property {number} level - The current level.\n     */\n    this.level = 0;\n\n    /**\n     * @property {object} bounds - Object that contains the octree bounds.\n     */\n    this.bounds = {};\n\n    /**\n     * @property {array} objects - Array of octree children.\n     */\n    this.objects = [];\n\n    /**\n     * @property {array} nodes - Array of associated child nodes.\n     */\n    this.nodes = [];\n\n    /**\n     * @property {array} _empty - Internal empty array.\n     * @private\n     */\n    this._empty = [];\n\n    this.reset(x, y, z, widthX, widthY, height, maxObjects, maxLevels, level);\n  }\n\n  /**\n   * Resets the QuadTree.\n   *\n   * @method Octree#reset\n   * @param {number} x - The bottom-back coordinate of the octree.\n   * @param {number} y - The bottom-back coordinate of the octree.\n   * @param {number} z - The bottom-back coordinate of the octree.\n   * @param {number} widthX - The width X (breadth) of the octree.\n   * @param {number} widthY - The width Y (depth) of the octree.\n   * @param {number} height - The height (Z) of the octree.\n   * @param {number} [maxObjects=10] - The maximum number of objects per node.\n   * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n   * @param {number} [level=0] - Which level is this?\n   */\n\n\n  _createClass(Octree, [{\n    key: 'reset',\n    value: function reset(x, y, z, widthX, widthY, height, maxObjects, maxLevels, level) {\n      this.maxObjects = maxObjects || 10;\n      this.maxLevels = maxLevels || 4;\n      this.level = level || 0;\n\n      this.bounds = {\n        x: Math.round(x),\n        y: Math.round(y),\n        z: Math.round(z),\n        widthX: widthX,\n        widthY: widthY,\n        height: height,\n        subWidthX: Math.floor(widthX * 0.5),\n        subWidthY: Math.floor(widthY * 0.5),\n        subHeight: Math.floor(height * 0.5),\n        frontX: Math.round(x) + Math.floor(widthX * 0.5),\n        frontY: Math.round(y) + Math.floor(widthY * 0.5),\n        top: Math.round(z) + Math.floor(height * 0.5)\n      };\n\n      this.objects.length = 0;\n      this.nodes.length = 0;\n    }\n\n    /**\n     * Populates this octree with the children of the given Group. In order to be added the child must exist and have a body property.\n     *\n     * @method Octree#populate\n     * @param {Phaser.Group} group - The Group to add to the octree.\n     */\n\n  }, {\n    key: 'populate',\n    value: function populate(group) {\n      var len = group.children.size;\n      var children = group.children.entries;\n\n      for (var i = 0; i < len; i++) {\n        this.populateHandler(children[i]);\n      }\n    }\n\n    /**\n     * Handler for the populate method.\n     *\n     * @method Octree#populateHandler\n     * @param {IsoSprite|object} sprite - The Sprite to check.\n     */\n\n  }, {\n    key: 'populateHandler',\n    value: function populateHandler(sprite) {\n      if (sprite.body) {\n        this.insert(sprite.body);\n      }\n    }\n\n    /**\n     * Split the node into 8 subnodes\n     *\n     * @method Octree#split\n     */\n\n  }, {\n    key: 'split',\n    value: function split() {\n      //  bottom four octants\n      //  -x-y-z\n      this.nodes[0] = new Octree(this.bounds.x, this.bounds.y, this.bounds.z, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  +x-y-z\n      this.nodes[1] = new Octree(this.bounds.frontX, this.bounds.y, this.bounds.z, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  -x+y-z\n      this.nodes[2] = new Octree(this.bounds.x, this.bounds.frontY, this.bounds.z, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  +x+y-z\n      this.nodes[3] = new Octree(this.bounds.frontX, this.bounds.frontY, this.bounds.z, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n\n      //  top four octants\n      //  -x-y+z\n      this.nodes[4] = new Octree(this.bounds.x, this.bounds.y, this.bounds.top, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  +x-y+z\n      this.nodes[5] = new Octree(this.bounds.frontX, this.bounds.y, this.bounds.top, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  -x+y+z\n      this.nodes[6] = new Octree(this.bounds.x, this.bounds.frontY, this.bounds.top, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n      //  +x+y+z\n      this.nodes[7] = new Octree(this.bounds.frontX, this.bounds.frontY, this.bounds.top, this.bounds.subWidthX, this.bounds.subWidthY, this.bounds.subHeight, this.maxLevels, this.level + 1);\n    }\n\n    /**\n     * Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.\n     *\n     * @method Octree#insert\n     * @param {Body|Cube|object} body - The Body object to insert into the octree. Can be any object so long as it exposes x, y, z, frontX, frontY and top properties.\n     */\n\n  }, {\n    key: 'insert',\n    value: function insert(body) {\n      var i = 0;\n      var index;\n\n      //  if we have subnodes ...\n      if (this.nodes[0] != null) {\n        index = this.getIndex(body);\n\n        if (index != -1) {\n          this.nodes[index].insert(body);\n          return;\n        }\n      }\n\n      this.objects.push(body);\n\n      if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n        //  Split if we don't already have subnodes\n        if (this.nodes[0] == null) {\n          this.split();\n        }\n\n        //  Add objects to subnodes\n        while (i < this.objects.length) {\n          index = this.getIndex(this.objects[i]);\n\n          if (index != -1) {\n            //  this is expensive - see what we can do about it\n            this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n          } else {\n            i++;\n          }\n        }\n      }\n    }\n\n    /**\n     * Determine which node the object belongs to.\n     *\n     * @method Octree#getIndex\n     * @param {Cube|object} cube - The bounds in which to check.\n     * @return {number} index - Index of the subnode (0-7), or -1 if cube cannot completely fit within a subnode and is part of the parent node.\n     */\n\n  }, {\n    key: 'getIndex',\n    value: function getIndex(cube) {\n      //  default is that cube doesn't fit, i.e. it straddles the internal octants\n      var index = -1;\n\n      if (cube.x < this.bounds.frontX && cube.frontX < this.bounds.frontX) {\n        if (cube.y < this.bounds.frontY && cube.frontY < this.bounds.frontY) {\n          if (cube.z < this.bounds.top && cube.top < this.bounds.top) {\n            //  cube fits into -x-y-z octant\n            index = 0;\n          } else if (cube.z > this.bounds.top) {\n            //  cube fits into -x-y+z octant\n            index = 4;\n          }\n        } else if (cube.y > this.bounds.frontY) {\n          if (cube.z < this.bounds.top && cube.top < this.bounds.top) {\n            //  cube fits into -x+y-z octant\n            index = 2;\n          } else if (cube.z > this.bounds.top) {\n            //  cube fits into -x+y+z octant\n            index = 6;\n          }\n        }\n      } else if (cube.x > this.bounds.frontX) {\n        if (cube.y < this.bounds.frontY && cube.frontY < this.bounds.frontY) {\n          if (cube.z < this.bounds.top && cube.top < this.bounds.top) {\n            //  cube fits into +x-y-z octant\n            index = 1;\n          } else if (cube.z > this.bounds.top) {\n            //  cube fits into +x-y+z octant\n            index = 5;\n          }\n        } else if (cube.y > this.bounds.frontY) {\n          if (cube.z < this.bounds.top && cube.top < this.bounds.top) {\n            //  cube fits into +x+y-z octant\n            index = 3;\n          } else if (cube.z > this.bounds.top) {\n            //  cube fits into +x+y+z octant\n            index = 7;\n          }\n        }\n      }\n\n      return index;\n    }\n\n    /**\n     * Return all objects that could collide with the given IsoSprite or Cube.\n     *\n     * @method Octree#retrieve\n     * @param {IsoSprite|Cube} source - The source object to check the Octree against. Either a IsoSprite or Cube.\n     * @return {array} - Array with all detected objects.\n     */\n\n  }, {\n    key: 'retrieve',\n    value: function retrieve(source) {\n      var returnObjects, index;\n\n      if (source instanceof _Cube2.default) {\n        returnObjects = this.objects;\n\n        index = this.getIndex(source);\n      } else {\n        if (!source.body) {\n          return this._empty;\n        }\n\n        returnObjects = this.objects;\n\n        index = this.getIndex(source.body);\n      }\n\n      if (this.nodes[0]) {\n        //  If cube fits into a subnode ..\n        if (index !== -1) {\n          returnObjects = returnObjects.concat(this.nodes[index].retrieve(source));\n        } else {\n          //  If cube does not fit into a subnode, check it against all subnodes (unrolled for speed)\n          returnObjects = returnObjects.concat(this.nodes[0].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[1].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[2].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[3].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[4].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[5].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[6].retrieve(source));\n          returnObjects = returnObjects.concat(this.nodes[7].retrieve(source));\n        }\n      }\n\n      return returnObjects;\n    }\n\n    /**\n     * Clear the octree.\n     * @method Octree#clear\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.objects.length = 0;\n\n      var i = this.nodes.length;\n\n      while (i--) {\n        this.nodes[i].clear();\n        this.nodes.splice(i, 1);\n      }\n\n      this.nodes.length = 0;\n    }\n  }]);\n\n  return Octree;\n}();\n\n/**\n * Visually renders an Octree to the display.\n *\n * @method Phaser.Utils.Debug#octree\n * @param {Octree} octree - The octree to render.\n * @param {string} color - The color of the lines in the quadtree.\n */\n// Phaser.Utils.Debug.prototype.octree = function (octree, color) {\n//   color = color || 'rgba(255,0,0,0.3)';\n//\n//   this.start();\n//\n//   var bounds = octree.bounds,\n//     i, points;\n//\n//   if (octree.nodes.length === 0) {\n//\n//     this.context.strokeStyle = color;\n//\n//     var cube = new Cube(bounds.x, bounds.y, bounds.z, bounds.widthX, bounds.widthY, bounds.height);\n//     var corners = cube.getCorners();\n//\n//     var posX = -this.game.camera.x;\n//     var posY = -this.game.camera.y;\n//\n//     points = corners.slice(0, corners.length);\n//\n//     points = points.map(function (p) {\n//       var newPos = this.game.iso.project(p);\n//       newPos.x += posX;\n//       newPos.y += posY;\n//       return newPos;\n//     });\n//\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.beginPath();\n//     this.context.strokeStyle = color;\n//\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.moveTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.moveTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.stroke();\n//     this.context.closePath();\n//\n//     for (i = 0; i < octree.objects.length; i++) {\n//       this.body(octree.objects[i].sprite, 'rgb(0,255,0)', false);\n//     }\n//   } else {\n//     for (i = 0; i < octree.nodes.length; i++) {\n//       this.octree(octree.nodes[i]);\n//     }\n//   }\n//\n//   this.stop();\n// };\n\nexports.default = Octree;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Octree.js?");

/***/ }),

/***/ "./src/Point3.js":
/*!***********************!*\
  !*** ./src/Point3.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Point3\n *\n * @classdesc\n * The Point3 object represents a location in a three-dimensional coordinate system,\n * where x and y represent the horizontal axes and z represents the vertical axis.\n * The following code creates a point at (0,0,0):\n * `var myPoint = new Point3();`\n *\n * Creates a new Point3 object. If you pass no parameters a Point3 is created set to (0, 0, 0).\n */\nvar Point3 = function () {\n  /**\n   * @constructor\n   * @param {number} [x=0] - The horizontal X position of this Point.\n   * @param {number} [y=0] - The horizontal Y position of this Point.\n   * @param {number} [z=0] - The vertical position of this Point.\n   */\n  function Point3() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Point3);\n\n    /**\n     * @property {number} x - The x value of the point.\n     */\n    this.x = x;\n\n    /**\n     * @property {number} y - The y value of the point.\n     */\n    this.y = y;\n\n    /**\n     * @property {number} z - The z value of the point.\n     */\n    this.z = z;\n  }\n\n  /**\n   * Copies the x, y and z properties from any given object to this Point3.\n   *\n   * @method Point3#copyFrom\n   * @param {any} source - The object to copy from.\n   * @return {Point3} This Point3 object.\n   */\n\n\n  _createClass(Point3, [{\n    key: 'copyFrom',\n    value: function copyFrom(source) {\n      return this.setTo(source.x, source.y, source.z);\n    }\n\n    /**\n     * Copies the x, y and z properties from this Point3 to any given object.\n     *\n     * @method Point3#copyTo\n     * @param {any} dest - The object to copy to.\n     * @return {Object} The dest object.\n     */\n\n  }, {\n    key: 'copyTo',\n    value: function copyTo(dest) {\n      dest.x = this.x;\n      dest.y = this.y;\n      dest.z = this.z;\n\n      return dest;\n    }\n\n    /**\n     * Determines whether the given object's x/y/z values are equal to this Point3 object.\n     *\n     * @method Point3#equals\n     * @param {Point3|any} a - The object to compare with this Point3.\n     * @return {boolean} A value of true if the x and y points are equal, otherwise false.\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(a) {\n      return a.x === this.x && a.y === this.y && a.z === this.z;\n    }\n\n    /**\n     * Sets the x, y and z values of this Point3 object to the given values.\n     * If you omit the y and z value then the x value will be applied to all three, for example:\n     * `Point3.set(2)` is the same as `Point3.set(2, 2, 2)`\n     * If however you set both x and y, but no z, the z value will be set to 0.\n     *\n     * @method Point3#set\n     * @param {number} x - The x value of this point.\n     * @param {number} [y] - The y value of this point. If not given the x value will be used in its place.\n     * @param {number} [z] - The z value of this point. If not given and the y value is also not given, the x value will be used in its place.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'set',\n    value: function set(x, y, z) {\n      this.x = x || 0;\n      this.y = y || (y !== 0 ? this.x : 0);\n      this.z = z || (typeof y === 'undefined' ? this.x : 0);\n    }\n\n    /**\n     * Sets the x, y and z values of this Point3 object to the given values.\n     * If you omit the y and z value then the x value will be applied to all three, for example:\n     * `Point3.setTo(2)` is the same as `Point3.setTo(2, 2, 2)`\n     * If however you set both x and y, but no z, the z value will be set to 0.\n     *\n     * @method Point3#setTo\n     * @param {number} x - The x value of this point.\n     * @param {number} [y] - The y value of this point. If not given the x value will be used in its place.\n     * @param {number} [z] - The z value of this point. If not given and the y value is also not given, the x value will be used in its place.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'setTo',\n    value: function setTo(x, y, z) {\n      return this.set(x, y, z);\n    }\n\n    /**\n     * Adds the given x, y and z values to this Point3.\n     *\n     * @method Point3#add\n     * @param {number} x - The value to add to Point3.x.\n     * @param {number} y - The value to add to Point3.y.\n     * @param {number} z - The value to add to Point3.z.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'add',\n    value: function add(x, y, z) {\n      this.x += x || 0;\n      this.y += y || 0;\n      this.z += z || 0;\n\n      return this;\n    }\n\n    /**\n     * Subtracts the given x, y and z values from this Point3.\n     *\n     * @method Point3#subtract\n     * @param {number} x - The value to subtract from Point3.x.\n     * @param {number} y - The value to subtract from Point3.y.\n     * @param {number} z - The value to subtract from Point3.z.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'subtract',\n    value: function subtract(x, y, z) {\n      this.x -= x || 0;\n      this.y -= y || 0;\n      this.z -= z || 0;\n\n      return this;\n    }\n\n    /**\n     * Multiplies Point3.x, Point3.y and Point3.z by the given x and y values. Sometimes known as `Scale`.\n     *\n     * @method Point3#multiply\n     * @param {number} x - The value to multiply Point3.x by.\n     * @param {number} y - The value to multiply Point3.y by.\n     * @param {number} z - The value to multiply Point3.z by.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'multiply',\n    value: function multiply(x, y, z) {\n      this.x *= x || 1;\n      this.y *= y || 1;\n      this.z *= z || 1;\n\n      return this;\n    }\n\n    /**\n     * Divides Point3.x, Point3.y and Point3.z by the given x, y and z values.\n     *\n     * @method Point3#divide\n     * @param {number} x - The value to divide Point3.x by.\n     * @param {number} y - The value to divide Point3.y by.\n     * @param {number} z - The value to divide Point3.z by.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'divide',\n    value: function divide(x, y, z) {\n      this.x /= x || 1;\n      this.y /= y || 1;\n      this.z /= z || 1;\n\n      return this;\n    }\n\n    /**\n     * Adds the coordinates of two points together to create a new point.\n     *\n     * @method Point3.add\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }], [{\n    key: 'add',\n    value: function add(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x + b.x;\n      out.y = a.y + b.y;\n      out.z = a.z + b.z;\n\n      return out;\n    }\n\n    /**\n     * Subtracts the coordinates of two points to create a new point.\n     *\n     * @method Point3.subtract\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'subtract',\n    value: function subtract(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x - b.x;\n      out.y = a.y - b.y;\n      out.z = a.z - b.z;\n\n      return out;\n    }\n\n    /**\n     * Multiplies the coordinates of two points to create a new point.\n     *\n     * @method Point3.multiply\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'multiply',\n    value: function multiply(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x * b.x;\n      out.y = a.y * b.y;\n      out.z = a.z * b.z;\n\n      return out;\n    }\n\n    /**\n     * Divides the coordinates of two points to create a new point.\n     *\n     * @method Point3.divide\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object3 will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'divide',\n    value: function divide(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x / b.x;\n      out.y = a.y / b.y;\n      out.z = a.z / b.z;\n\n      return out;\n    }\n\n    /**\n     * Determines whether the two given Point3 objects are equal. They are considered equal if they have the same x, y and z values.\n     *\n     * @method Point3.equals\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @return {boolean} A value of true if the Points3 are equal, otherwise false.\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(a, b) {\n      return a.x === b.x && a.y === b.y && a.z === b.z;\n    }\n  }]);\n\n  return Point3;\n}();\n\nexports.default = Point3;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Point3.js?");

/***/ }),

/***/ "./src/Projector.js":
/*!**************************!*\
  !*** ./src/Projector.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MILITARY = exports.ISOMETRIC = exports.CLASSIC = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Point = Phaser.Geom.Point;\n\n//  Projection angles\nvar CLASSIC = exports.CLASSIC = Math.atan(0.5);\nvar ISOMETRIC = exports.ISOMETRIC = Math.PI / 6;\nvar MILITARY = exports.MILITARY = Math.PI / 4;\n\n/**\n * @class Projector\n *\n * @classdesc\n * Creates a new Isometric Projector object, which has helpers for projecting x, y and z coordinates into axonometric x and y equivalents.\n */\n\nvar Projector = function () {\n  /**\n  * @constructor\n  * @param {Phaser.Game} game - The current game object.\n  * @param {number} projectionAngle - The angle of the axonometric projection in radians. Defaults to approx. 0.4636476 (Math.atan(0.5) which is suitable for 2:1 pixel art dimetric)\n  * @return {Cube} This Cube object.\n  */\n  function Projector(scene, projectionAngle) {\n    _classCallCheck(this, Projector);\n\n    /**\n     * @property {Phaser.Scene} scne - The current scene object.\n     */\n    this.scene = scene;\n\n    /**\n     * @property {array} _transform - The pre-calculated axonometric transformation values.\n     * @private\n     */\n    this._transform = null;\n\n    /**\n     * @property {number} _projectionAngle - The cached angle of projection in radians.\n     * @private\n     */\n    this._projectionAngle = 0;\n\n    /**\n     * @property {number} projectionAngle - The angle of projection in radians.\n     * @default\n     */\n    this.projectionAngle = projectionAngle || CLASSIC;\n\n    /**\n     * @property {Phaser.Geom.Point} origin - The x and y offset multipliers as a ratio of the game world size.\n     * @default\n     */\n    this.origin = new Point(0.5, 0.5);\n  }\n\n  /**\n   * @name Projector#projectionAngle\n   * @property {number} projectionAngle - The angle of axonometric projection.\n   */\n\n\n  _createClass(Projector, [{\n    key: 'project',\n\n\n    /**\n     * Use axonometric projection to transform a 3D Point3 coordinate to a 2D Point coordinate. If given the coordinates will be set into the object, otherwise a brand new Point object will be created and returned.\n     * @method Projector#project\n     * @param {Point3} point3 - The Point3 to project from.\n     * @param {Phaser.Geom.Point} out - The Point to project to.\n     * @return {Phaser.Geom.Point} The transformed Point.\n     */\n    value: function project(point3) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();\n\n      out.x = (point3.x - point3.y) * this._transform[0];\n      out.y = (point3.x + point3.y) * this._transform[1] - point3.z;\n\n      var _scene$sys$game$confi = this.scene.sys.game.config,\n          width = _scene$sys$game$confi.width,\n          height = _scene$sys$game$confi.height;\n\n      out.x += width * this.origin.x;\n      out.y += height * this.origin.y;\n\n      return out;\n    }\n\n    /**\n     * Use axonometric projection to transform a 3D Point3 coordinate to a 2D Point coordinate, ignoring the z-axis. If given the coordinates will be set into the object, otherwise a brand new Point object will be created and returned.\n     * @method Projector#projectXY\n     * @param {Point3} point3 - The Point3 to project from.\n     * @param {Phaser.Geom.Point} out - The Point to project to.\n     * @return {Phaser.Geom.Point} The transformed Point.\n     */\n\n  }, {\n    key: 'projectXY',\n    value: function projectXY(point3) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();\n\n      out.x = (point3.x - point3.y) * this._transform[0];\n      out.y = (point3.x + point3.y) * this._transform[1];\n\n      out.x += this.game.world.width * this.origin.x;\n      out.y += this.game.world.height * this.origin.y;\n\n      return out;\n    }\n\n    /**\n     * Use reverse axonometric projection to transform a 2D Point coordinate to a 3D Point3 coordinate. If given the coordinates will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @method Projector#unproject\n     * @param {Phaser.Geom.Point} point - The Point to project from.\n     * @param {Point3} out - The Point3 to project to.\n     * @param {number} [z] - Specified z-plane to project to.\n     * @return {Point3} The transformed Point3.\n     */\n\n  }, {\n    key: 'unproject',\n    value: function unproject(point) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _Point2.default();\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var x = point.x - this.game.world.x - this.game.world.width * this.origin.x;\n      var y = point.y - this.game.world.y - this.game.world.height * this.origin.y + z;\n\n      out.x = x / (2 * this._transform[0]) + y / (2 * this._transform[1]);\n      out.y = -(x / (2 * this._transform[0])) + y / (2 * this._transform[1]);\n      out.z = z;\n\n      return out;\n    }\n  }, {\n    key: 'projectionAngle',\n    set: function set(angle) {\n      if (angle === this._projectionAngle) {\n        return;\n      }\n\n      this._projectionAngle = angle;\n      this._transform = [Math.cos(this._projectionAngle), Math.sin(this._projectionAngle)];\n    },\n    get: function get() {\n      return this._projectionAngle;\n    }\n  }]);\n\n  return Projector;\n}();\n\nexports.default = Projector;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Projector.js?");

/***/ }),

/***/ "./src/physics/Body.js":
/*!*****************************!*\
  !*** ./src/physics/Body.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TYPE = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ../Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Cube = __webpack_require__(/*! ../Cube */ \"./src/Cube.js\");\n\nvar _Cube2 = _interopRequireDefault(_Cube);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UP = 0;\nvar DOWN = 1;\nvar FORWARDX = 2;\nvar FORWARDY = 3;\nvar BACKWARDX = 4;\nvar BACKWARDY = 5;\nvar TYPE = exports.TYPE = 'IsoPhysics';\n\n/**\n * @class Isometric.Body\n *\n * @classdesc\n * The Physics Body is linked to a single IsoSprite. All physics operations should be performed against the body rather than\n * the IsoSprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.\n */\n\nvar Body = function () {\n  /*\n   * @constructor\n   * @param {IsoSprite} sprite - The IsoSprite object this physics body belongs to.\n   */\n  function Body(sprite) {\n    _classCallCheck(this, Body);\n\n    /**\n     * @property {IsoSprite} sprite - Reference to the parent IsoSprite.\n     */\n    this.sprite = sprite;\n\n    /**\n     * @property {Phaser.Scene} scene - Local reference to scene.\n     */\n    this.scene = sprite.scene;\n\n    /**\n     * @property {number} type - The type of physics system this body belongs to.\n     */\n    this.type = TYPE;\n\n    /**\n     * @property {boolean} enable - A disabled body won't be checked for any form of collision or overlap or have its pre/post updates run.\n     * @default\n     */\n    this.enable = true;\n\n    /**\n     * @property {Phaser.Point} offset - The offset of the Physics Body from the IsoSprite x/y/z position.\n     */\n    this.offset = new _Point2.default();\n\n    /**\n     * @property {Point3} position - The position of the physics body.\n     * @readonly\n     */\n    this.position = new _Point2.default(sprite.isoX, sprite.isoY, sprite.isoZ);\n\n    /**\n     * @property {Phaser.Point} prev - The previous position of the physics body.\n     * @readonly\n     */\n    this.prev = new _Point2.default(this.position.x, this.position.y, this.position.z);\n\n    /**\n     * @property {boolean} allowRotation - Allow this Body to be rotated? (via angularVelocity, etc)\n     * @default\n     */\n    this.allowRotation = true;\n\n    /**\n     * @property {number} rotation - The amount the Body is rotated.\n     */\n    this.rotation = sprite.rotation;\n\n    /**\n     * @property {number} preRotation - The previous rotation of the physics body.\n     * @readonly\n     */\n    this.preRotation = sprite.rotation;\n\n    /**\n     * @property {number} sourceWidthX - The un-scaled original size.\n     * @readonly\n     */\n    this.sourceWidthX = sprite.width / sprite.scaleX;\n\n    /**\n     * @property {number} sourceWidthY - The un-scaled original size.\n     * @readonly\n     */\n    this.sourceWidthY = sprite.width / sprite.scaleX;\n\n    /**\n     * @property {number} sourceHeight - The un-scaled original size.\n     * @readonly\n     */\n    this.sourceHeight = sprite.height / sprite.scaleY;\n\n    /**\n     * @property {number} widthX - The calculated X width (breadth) of the physics body.\n     */\n    this.widthX = Math.ceil(sprite.width * 0.5);\n\n    /**\n     * @property {number} widthY - The calculated Y width (depth) of the physics body.\n     */\n    this.widthY = Math.ceil(sprite.width * 0.5);\n\n    /**\n     * @property {number} height - The calculated height of the physics body.\n     */\n    this.height = sprite.height - Math.ceil(sprite.width * 0.5);\n\n    /**\n     * @property {number} halfWidthX - The calculated X width / 2 of the physics body.\n     */\n    this.halfWidthX = Math.abs(this.widthX * 0.5);\n\n    /**\n     * @property {number} halfWidthX - The calculated X width / 2 of the physics body.\n     */\n    this.halfWidthY = Math.abs(this.widthY * 0.5);\n\n    /**\n     * @property {number} halfHeight - The calculated height / 2 of the physics body.\n     */\n    this.halfHeight = Math.abs(this.height * 0.5);\n\n    /**\n     * @property {Point3} center - The center coordinate of the physics body.\n     */\n    this.center = new _Point2.default(sprite.isoX + this.halfWidthX, sprite.isoY + this.halfWidthY, sprite.isoZ + this.halfHeight);\n\n    /**\n     * @property {Point3} velocity - The velocity in pixels per second sq. of the Body.\n     */\n    this.velocity = new _Point2.default();\n\n    /**\n     * @property {Point3} newVelocity - New velocity.\n     * @readonly\n     */\n    this.newVelocity = new _Point2.default();\n\n    /**\n     * @property {Point3} deltaMax - The Sprite position is updated based on the delta x/y values. You can set a cap on those (both +-) using deltaMax.\n     */\n    this.deltaMax = new _Point2.default();\n\n    /**\n     * @property {Point3} acceleration - The velocity in pixels per second sq. of the Body.\n     */\n    this.acceleration = new _Point2.default();\n\n    /**\n     * @property {Point3} drag - The drag applied to the motion of the Body.\n     */\n    this.drag = new _Point2.default();\n\n    /**\n     * @property {boolean} allowGravity - Allow this Body to be influenced by gravity? Either world or local.\n     * @default\n     */\n    this.allowGravity = true;\n\n    /**\n     * @property {Point3} gravity - A local gravity applied to this Body. If non-zero this over rides any world gravity, unless Body.allowGravity is set to false.\n     */\n    this.gravity = new _Point2.default();\n\n    /**\n     * @property {Point3} bounce - The elasticitiy of the Body when colliding. bounce.x/y/z = 1 means full rebound, bounce.x/y/z = 0.5 means 50% rebound velocity.\n     */\n    this.bounce = new _Point2.default();\n\n    /**\n     * @property {Point3} maxVelocity - The maximum velocity in pixels per second sq. that the Body can reach.\n     * @default\n     */\n    this.maxVelocity = new _Point2.default(10000, 10000, 10000);\n\n    /**\n     * @property {number} angularVelocity - The angular velocity in pixels per second sq. of the Body.\n     * @default\n     */\n    this.angularVelocity = 0;\n\n    /**\n     * @property {number} angularAcceleration - The angular acceleration in pixels per second sq. of the Body.\n     * @default\n     */\n    this.angularAcceleration = 0;\n\n    /**\n     * @property {number} angularDrag - The angular drag applied to the rotation of the Body.\n     * @default\n     */\n    this.angularDrag = 0;\n\n    /**\n     * @property {number} maxAngular - The maximum angular velocity in pixels per second sq. that the Body can reach.\n     * @default\n     */\n    this.maxAngular = 1000;\n\n    /**\n     * @property {number} mass - The mass of the Body.\n     * @default\n     */\n    this.mass = 1;\n\n    /**\n     * @property {number} angle - The angle of the Body in radians as calculated by its velocity, rather than its visual angle.\n     * @readonly\n     */\n    this.angle = 0;\n\n    /**\n     * @property {number} speed - The speed of the Body as calculated by its velocity.\n     * @readonly\n     */\n    this.speed = 0;\n\n    /**\n     * @property {number} facing - A const reference to the direction the Body is traveling or facing.\n     * @default\n     */\n    this.facing = Phaser.NONE;\n\n    /**\n     * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies.\n     * @default\n     */\n    this.immovable = false;\n\n    /**\n     * If you have a Body that is being moved around the world via a tween or a Group motion, but its local x/y position never\n     * actually changes, then you should set Body.moves = false. Otherwise it will most likely fly off the screen.\n     * If you want the physics system to move the body around, then set moves to true.\n     * @property {boolean} moves - Set to true to allow the Physics system to move this Body, other false to move it manually.\n     * @default\n     */\n    this.moves = true;\n\n    /**\n     * This flag allows you to disable the custom x separation that takes place by Physics.IsoArcade.separate.\n     * Used in combination with your own collision processHandler you can create whatever type of collision response you need.\n     * @property {boolean} customSeparateX - Use a custom separation system or the built-in one?\n     * @default\n     */\n    this.customSeparateX = false;\n\n    /**\n     * This flag allows you to disable the custom y separation that takes place by Physics.IsoArcade.separate.\n     * Used in combination with your own collision processHandler you can create whatever type of collision response you need.\n     * @property {boolean} customSeparateY - Use a custom separation system or the built-in one?\n     * @default\n     */\n    this.customSeparateY = false;\n\n    /**\n     * This flag allows you to disable the custom z separation that takes place by Physics.IsoArcade.separate.\n     * Used in combination with your own collision processHandler you can create whatever type of collision response you need.\n     * @property {boolean} customSeparateZ - Use a custom separation system or the built-in one?\n     * @default\n     */\n    this.customSeparateZ = false;\n\n    /**\n     * When this body collides with another, the amount of overlap is stored here.\n     * @property {number} overlapX - The amount of horizontal overlap during the collision.\n     */\n    this.overlapX = 0;\n\n    /**\n     * When this body collides with another, the amount of overlap is stored here.\n     * @property {number} overlapY - The amount of vertical overlap during the collision.\n     */\n    this.overlapY = 0;\n\n    /**\n     * When this body collides with another, the amount of overlap is stored here.\n     * @property {number} overlapY - The amount of vertical overlap during the collision.\n     */\n    this.overlapZ = 0;\n\n    /**\n     * If a body is overlapping with another body, but neither of them are moving (maybe they spawned on-top of each other?) this is set to true.\n     * @property {boolean} embedded - Body embed value.\n     */\n    this.embedded = false;\n\n    /**\n     * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.\n     * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\n     */\n    this.collideWorldBounds = false;\n\n    /**\n     * Set the checkCollision properties to control which directions collision is processed for this Body.\n     * For example checkCollision.up = false means it won't collide when the collision happened while moving up.\n     * @property {object} checkCollision - An object containing allowed collision.\n     */\n    this.checkCollision = {\n      none: false,\n      any: true,\n      up: true,\n      down: true,\n      frontX: true,\n      frontY: true,\n      backX: true,\n      backY: true\n    };\n\n    /**\n     * This object is populated with boolean values when the Body collides with another.\n     * touching.up = true means the collision happened to the top of this Body for example.\n     * @property {object} touching - An object containing touching results.\n     */\n    this.touching = {\n      none: true,\n      up: false,\n      down: false,\n      frontX: false,\n      frontY: false,\n      backX: false,\n      backY: false\n    };\n\n    /**\n     * This object is populated with previous touching values from the bodies previous collision.\n     * @property {object} wasTouching - An object containing previous touching results.\n     */\n    this.wasTouching = {\n      none: true,\n      up: false,\n      down: false,\n      frontX: false,\n      frontY: false,\n      backX: false,\n      backY: false\n    };\n\n    /**\n     * This object is populated with boolean values when the Body collides with the World bounds or a Tile.\n     * For example if blocked.up is true then the Body cannot move up.\n     * @property {object} blocked - An object containing on which faces this Body is blocked from moving, if any.\n     */\n    this.blocked = {\n      up: false,\n      down: false,\n      frontX: false,\n      frontY: false,\n      backX: false,\n      backY: false\n    };\n\n    /**\n     * @property {number} phase - Is this Body in a update (1) or postUpdate (2) state?\n     */\n    this.phase = 0;\n\n    /**\n     * @property {boolean} skipTree - If true and you collide this IsoSprite against a Group, it will disable the collision check from using an Octree.\n     */\n    this.skipTree = false;\n\n    /**\n     * @property {boolean} _reset - Internal cache var.\n     * @private\n     */\n    this._reset = true;\n\n    /**\n     * @property {number} _sx - Internal cache var.\n     * @private\n     */\n    this._sx = sprite.scaleX;\n\n    /**\n     * @property {number} _sy - Internal cache var.\n     * @private\n     */\n    this._sy = sprite.scaleY;\n\n    /**\n     * @property {number} _dx - Internal cache var.\n     * @private\n     */\n    this._dx = 0;\n\n    /**\n     * @property {number} _dy - Internal cache var.\n     * @private\n     */\n    this._dy = 0;\n\n    /**\n     * @property {number} _dz - Internal cache var.\n     * @private\n     */\n    this._dz = 0;\n\n    /**\n     * @property {Array.<Point3>} _corners - The 8 corners of the bounding cube.\n     * @private\n     */\n    this._corners = [new _Point2.default(this.x, this.y, this.z), new _Point2.default(this.x, this.y, this.z + this.height), new _Point2.default(this.x, this.y + this.widthY, this.z), new _Point2.default(this.x, this.y + this.widthY, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y, this.z), new _Point2.default(this.x + this.widthX, this.y, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z + this.height)];\n  }\n\n  /**\n   * Internal method.\n   *\n   * @method Body#updateBounds\n   * @protected\n   */\n\n\n  _createClass(Body, [{\n    key: 'updateBounds',\n    value: function updateBounds() {\n      var asx = Math.abs(this.sprite.scaleX);\n      var asy = Math.abs(this.sprite.scaleY);\n\n      if (asx !== this._sx || asy !== this._sy) {\n        this.widthX = Math.ceil(this.sprite.width * 0.5);\n        this.widthY = Math.ceil(this.sprite.width * 0.5);\n        this.height = Math.ceil(this.sprite.height - this.sprite.width * 0.5);\n        this.halfWidthX = Math.floor(this.widthX * 0.5);\n        this.halfWidthY = Math.floor(this.widthY * 0.5);\n        this.halfHeight = Math.floor(this.height * 0.5);\n        this._sx = asx;\n        this._sy = asy;\n        this.center.setTo(this.position.x + this.halfWidthX, this.position.y + this.halfWidthY, this.position.z + this.halfHeight);\n\n        this._reset = true;\n      }\n    }\n\n    /**\n     * Internal method.\n     *\n     * @method Body#update\n     * @protected\n     */\n\n  }, {\n    key: 'update',\n    value: function update(time, delta) {\n      if (!this.enable) {\n        return;\n      }\n\n      this.phase = 1;\n\n      //  Store and reset collision flags\n      this.wasTouching.none = this.touching.none;\n      this.wasTouching.up = this.touching.up;\n      this.wasTouching.down = this.touching.down;\n      this.wasTouching.backX = this.touching.backX;\n      this.wasTouching.backY = this.touching.backY;\n      this.wasTouching.frontX = this.touching.frontX;\n      this.wasTouching.frontY = this.touching.frontY;\n\n      this.touching.none = true;\n      this.touching.up = false;\n      this.touching.down = false;\n      this.touching.backX = false;\n      this.touching.backY = false;\n      this.touching.frontX = false;\n      this.touching.frontY = false;\n\n      this.blocked.up = false;\n      this.blocked.down = false;\n      this.blocked.frontY = false;\n      this.blocked.frontX = false;\n      this.blocked.backY = false;\n      this.blocked.backX = false;\n\n      this.embedded = false;\n\n      this.updateBounds();\n\n      //  Working out how to incorporate anchors into this was... fun.\n      this.position.x = this.sprite.isoX + (this.widthX * -this.sprite.originX + this.widthX * 0.5) + this.offset.x;\n      this.position.y = this.sprite.isoY + (this.widthY * this.sprite.originX - this.widthY * 0.5) + this.offset.y;\n      this.position.z = this.sprite.isoZ - Math.abs(this.sprite.height) * (1 - this.sprite.originY) + Math.abs(this.sprite.width * 0.5) + this.offset.z;\n\n      this.rotation = this.sprite.angle;\n\n      this.preRotation = this.rotation;\n\n      if (this._reset || this.sprite.fresh === true) {\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n        this.prev.z = this.position.z;\n      }\n\n      if (this.moves) {\n        var pluginKey = this.scene.sys.settings.map.isoPhysics;\n        var world = this.scene[pluginKey].world;\n\n        delta /= 1000;\n        world.updateMotion(this, delta);\n\n        this.newVelocity.set(this.velocity.x * delta, this.velocity.y * delta, this.velocity.z * delta);\n\n        this.position.x += this.newVelocity.x;\n        this.position.y += this.newVelocity.y;\n        this.position.z += this.newVelocity.z;\n\n        if (this.position.x !== this.prev.x || this.position.y !== this.prev.y || this.position.z !== this.prev.z) {\n          this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y + this.velocity.z * this.velocity.z);\n          this.angle = Math.atan2(this.velocity.y, this.velocity.x);\n        }\n\n        //  Now the State update will throw collision checks at the Body\n        //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n        if (this.collideWorldBounds) {\n          this.checkWorldBounds();\n        }\n\n        if (this.sprite.outOfBoundsKill && !world.bounds.intersects(this.sprite.isoBounds)) {\n          this.sprite.kill();\n        }\n      }\n\n      this._dx = this.deltaX();\n      this._dy = this.deltaY();\n      this._dz = this.deltaZ();\n\n      this._reset = false;\n    }\n\n    /**\n     * Internal method.\n     *\n     * @method Body#postUpdate\n     * @protected\n     */\n\n  }, {\n    key: 'postUpdate',\n    value: function postUpdate() {\n      //  Only allow postUpdate to be called once per frame\n      if (!this.enable || this.phase === 2) {\n        return;\n      }\n\n      this.phase = 2;\n\n      // stops sprites flying off if isoPosition is changed during update\n      if (this._reset) {\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n        this.prev.z = this.position.z;\n      }\n\n      if (this.deltaAbsX() >= this.deltaAbsY() && this.deltaAbsX() >= this.deltaAbsZ()) {\n        if (this.deltaX() < 0) {\n          this.facing = BACKWARDX;\n        } else if (this.deltaX() > 0) {\n          this.facing = FORWARDX;\n        }\n      } else if (this.deltaAbsY() >= this.deltaAbsX() && this.deltaAbsY() >= this.deltaAbsZ()) {\n        if (this.deltaY() < 0) {\n          this.facing = BACKWARDY;\n        } else if (this.deltaY() > 0) {\n          this.facing = FORWARDY;\n        }\n      } else {\n        if (this.deltaZ() < 0) {\n          this.facing = DOWN;\n        } else if (this.deltaZ() > 0) {\n          this.facing = UP;\n        }\n      }\n\n      if (this.moves) {\n        this._dx = this.deltaX();\n        this._dy = this.deltaY();\n        this._dz = this.deltaZ();\n\n        if (this.deltaMax.x !== 0 && this._dx !== 0) {\n          if (this._dx < 0 && this._dx < -this.deltaMax.x) {\n            this._dx = -this.deltaMax.x;\n          } else if (this._dx > 0 && this._dx > this.deltaMax.x) {\n            this._dx = this.deltaMax.x;\n          }\n        }\n\n        if (this.deltaMax.y !== 0 && this._dy !== 0) {\n          if (this._dy < 0 && this._dy < -this.deltaMax.y) {\n            this._dy = -this.deltaMax.y;\n          } else if (this._dy > 0 && this._dy > this.deltaMax.y) {\n            this._dy = this.deltaMax.y;\n          }\n        }\n\n        if (this.deltaMax.z !== 0 && this._dz !== 0) {\n          if (this._dz < 0 && this._dz < -this.deltaMax.z) {\n            this._dz = -this.deltaMax.z;\n          } else if (this._dz > 0 && this._dz > this.deltaMax.z) {\n            this._dz = this.deltaMax.z;\n          }\n        }\n\n        this.sprite.isoX += this._dx;\n        this.sprite.isoY += this._dy;\n        this.sprite.isoZ += this._dz;\n      }\n\n      this.center.setTo(this.position.x + this.halfWidthX, this.position.y + this.halfWidthY, this.position.z + this.halfHeight);\n\n      if (this.allowRotation) {\n        this.sprite.angle += this.deltaR();\n      }\n\n      this.prev.x = this.position.x;\n      this.prev.y = this.position.y;\n      this.prev.z = this.position.z;\n\n      this._reset = false;\n    }\n\n    /**\n     * Removes this body's reference to its parent sprite, freeing it up for gc.\n     *\n     * @method Body#destroy\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.sprite = null;\n    }\n\n    /**\n     * Internal method.\n     *\n     * @method Body#checkWorldBounds\n     * @protected\n     */\n\n  }, {\n    key: 'checkWorldBounds',\n    value: function checkWorldBounds() {\n      var pluginKey = this.scene.sys.settings.map.isoPhysics;\n      var world = this.scene[pluginKey].world;\n\n\n      if (this.position.x < world.bounds.x && world.checkCollision.backX) {\n        this.position.x = world.bounds.x;\n        this.velocity.x *= -this.bounce.x;\n        this.blocked.backX = true;\n      } else if (this.frontX > world.bounds.frontX && world.checkCollision.frontX) {\n        this.position.x = world.bounds.frontX - this.widthX;\n        this.velocity.x *= -this.bounce.x;\n        this.blocked.frontX = true;\n      }\n\n      if (this.position.y < world.bounds.y && world.checkCollision.backY) {\n        this.position.y = world.bounds.y;\n        this.velocity.y *= -this.bounce.y;\n        this.blocked.backY = true;\n      } else if (this.frontY > world.bounds.frontY && world.checkCollision.frontY) {\n        this.position.y = world.bounds.frontY - this.widthY;\n        this.velocity.y *= -this.bounce.y;\n        this.blocked.frontY = true;\n      }\n\n      if (this.position.z < world.bounds.z && world.checkCollision.down) {\n        this.position.z = world.bounds.z;\n        this.velocity.z *= -this.bounce.z;\n        this.blocked.down = true;\n      } else if (this.top > world.bounds.top && world.checkCollision.up) {\n        this.position.z = world.bounds.top - this.height;\n        this.velocity.z *= -this.bounce.z;\n        this.blocked.up = true;\n      }\n    }\n\n    /**\n     * You can modify the size of the physics Body to be any dimension you need.\n     * So it could be smaller or larger than the parent Sprite. You can also control the x, y and z offset, which\n     * is the position of the Body relative to the center of the Sprite.\n     *\n     * @method Body#setSize\n     * @param {number} widthX - The X width (breadth) of the Body.\n     * @param {number} widthY - The Y width (depth) of the Body.\n     * @param {number} height - The height of the Body.\n     * @param {number} [offsetX] - The X offset of the Body from the Sprite position.\n     * @param {number} [offsetY] - The Y offset of the Body from the Sprite position.\n     * @param {number} [offsetZ] - The Z offset of the Body from the Sprite position.\n     */\n\n  }, {\n    key: 'setSize',\n    value: function setSize(widthX, widthY, height, offsetX, offsetY, offsetZ) {\n      if (typeof offsetX === 'undefined') {\n        offsetX = this.offset.x;\n      }\n      if (typeof offsetY === 'undefined') {\n        offsetY = this.offset.y;\n      }\n      if (typeof offsetZ === 'undefined') {\n        offsetZ = this.offset.z;\n      }\n\n      this.sourceWidthX = widthX;\n      this.sourceWidthY = widthY;\n      this.sourceHeight = height;\n      this.widthX = this.sourceWidthX * this._sx;\n      this.widthY = this.sourceWidthY * this._sx;\n      this.height = this.sourceHeight * this._sy;\n      this.halfWidthX = Math.floor(this.widthX * 0.5);\n      this.halfWidthY = Math.floor(this.widthY * 0.5);\n      this.halfHeight = Math.floor(this.height * 0.5);\n      this.offset.setTo(offsetX, offsetY, offsetZ);\n\n      this.center.setTo(this.position.x + this.halfWidthX, this.position.y + this.halfWidthY, this.position.z + this.halfHeight);\n    }\n\n    /**\n     * Resets all Body values (velocity, acceleration, rotation, etc)\n     *\n     * @method Body#reset\n     * @param {number} x - The new x position of the Body.\n     * @param {number} y - The new y position of the Body.\n     * @param {number} z - The new z position of the Body.\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset(x, y, z) {\n      this.velocity.set(0);\n      this.acceleration.set(0);\n\n      this.angularVelocity = 0;\n      this.angularAcceleration = 0;\n\n      this.position.x = x + (this.widthX * -this.sprite.anchor.x + this.widthX * 0.5) + this.offset.x;\n      this.position.y = y + (this.widthY * this.sprite.anchor.x - this.widthY * 0.5) + this.offset.y;\n      this.position.z = z - Math.abs(this.sprite.height) * (1 - this.sprite.anchor.y) + Math.abs(this.sprite.width * 0.5) + this.offset.z;\n\n      this.prev.x = this.position.x;\n      this.prev.y = this.position.y;\n      this.prev.z = this.position.z;\n\n      this.rotation = this.sprite.angle;\n      this.preRotation = this.rotation;\n\n      this._sx = this.sprite.scaleX;\n      this._sy = this.sprite.scaleY;\n\n      this.center.setTo(this.position.x + this.halfWidthX, this.position.y + this.halfWidthY, this.position.z + this.halfHeight);\n\n      this.sprite._isoPositionChanged = true;\n    }\n\n    /**\n     * Tests if a world point lies within this Body.\n     *\n     * @method Body#hitTest\n     * @param {number} x - The world x coordinate to test.\n     * @param {number} y - The world y coordinate to test.\n     * @param {number} z - The world z coordinate to test.\n     * @return {boolean} True if the given coordinates are inside this Body, otherwise false.\n     */\n\n  }, {\n    key: 'hitTest',\n    value: function hitTest(x, y, z) {\n      return _Cube2.default.contains(this, x, y, z);\n    }\n\n    /**\n     * Returns true if the bottom of this Body is in contact with either the world bounds.\n     *\n     * @method Body#onFloor\n     * @return {boolean} True if in contact with either the world bounds.\n     */\n\n  }, {\n    key: 'onFloor',\n    value: function onFloor() {\n      return this.blocked.down;\n    }\n\n    /**\n     * Returns true if either side of this Body is in contact with either the world bounds.\n     *\n     * @method Body#onWall\n     * @return {boolean} True if in contact with world bounds.\n     */\n\n  }, {\n    key: 'onWall',\n    value: function onWall() {\n      return this.blocked.frontX || this.blocked.frontY || this.blocked.backX || this.blocked.backY;\n    }\n\n    /**\n     * Returns the absolute delta x value.\n     *\n     * @method Body#deltaAbsX\n     * @return {number} The absolute delta value.\n     */\n\n  }, {\n    key: 'deltaAbsX',\n    value: function deltaAbsX() {\n      return this.deltaX() > 0 ? this.deltaX() : -this.deltaX();\n    }\n\n    /**\n     * Returns the absolute delta y value.\n     *\n     * @method Body#deltaAbsY\n     * @return {number} The absolute delta value.\n     */\n\n  }, {\n    key: 'deltaAbsY',\n    value: function deltaAbsY() {\n      return this.deltaY() > 0 ? this.deltaY() : -this.deltaY();\n    }\n\n    /**\n     * Returns the absolute delta z value.\n     *\n     * @method Body#deltaAbsZ\n     * @return {number} The absolute delta value.\n     */\n\n  }, {\n    key: 'deltaAbsZ',\n    value: function deltaAbsZ() {\n      return this.deltaZ() > 0 ? this.deltaZ() : -this.deltaZ();\n    }\n\n    /**\n     * Returns the delta x value. The difference between Body.x now and in the previous step.\n     *\n     * @method Body#deltaX\n     * @return {number} The delta value. Positive if the motion was to the right, negative if to the left.\n     */\n\n  }, {\n    key: 'deltaX',\n    value: function deltaX() {\n      return this.position.x - this.prev.x;\n    }\n\n    /**\n     * Returns the delta y value. The difference between Body.y now and in the previous step.\n     *\n     * @method Body#deltaY\n     * @return {number} The delta value. Positive if the motion was downwards, negative if upwards.\n     */\n\n  }, {\n    key: 'deltaY',\n    value: function deltaY() {\n      return this.position.y - this.prev.y;\n    }\n\n    /**\n     * Returns the delta z value. The difference between Body.z now and in the previous step.\n     *\n     * @method Body#deltaZ\n     * @return {number} The delta value. Positive if the motion was downwards, negative if upwards.\n     */\n\n  }, {\n    key: 'deltaZ',\n    value: function deltaZ() {\n      return this.position.z - this.prev.z;\n    }\n\n    /**\n     * Returns the delta r value. The difference between Body.rotation now and in the previous step.\n     *\n     * @method Body#deltaR\n     * @return {number} The delta value. Positive if the motion was clockwise, negative if anti-clockwise.\n     */\n\n  }, {\n    key: 'deltaR',\n    value: function deltaR() {\n      return this.rotation - this.preRotation;\n    }\n\n    /**\n     * Returns the 8 corners that make up the body's bounding cube.\n     *\n     * @method Body#getCorners\n     * @return {Array.<Point3>} An array of Point3 values specifying each corner co-ordinate.\n     */\n\n  }, {\n    key: 'getCorners',\n    value: function getCorners() {\n      this._corners[0].setTo(this.x, this.y, this.z);\n      this._corners[1].setTo(this.x, this.y, this.z + this.height);\n      this._corners[2].setTo(this.x, this.y + this.widthY, this.z);\n      this._corners[3].setTo(this.x, this.y + this.widthY, this.z + this.height);\n      this._corners[4].setTo(this.x + this.widthX, this.y, this.z);\n      this._corners[5].setTo(this.x + this.widthX, this.y, this.z + this.height);\n      this._corners[6].setTo(this.x + this.widthX, this.y + this.widthY, this.z);\n      this._corners[7].setTo(this.x + this.widthX, this.y + this.widthY, this.z + this.height);\n\n      return this._corners;\n    }\n\n    /**\n     * @name Body#top\n     * @property {number} bottom - The top value of this Body (same as Body.z + Body.height)\n     * @readonly\n     */\n\n  }, {\n    key: 'debugRender',\n    value: function debugRender(context) {\n      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'rgba(0,255,0,0.4)';\n      var filled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var points = [];\n      var corners = this.getCorners();\n\n      var posX = -this.scene.cameras.main.x;\n      var posY = -this.scene.cameras.main.y;\n\n      var pluginKey = this.scene.sys.settings.map.isoPlugin;\n      var projector = this.scene[pluginKey].projector;\n\n      if (filled) {\n        points = [corners[1], corners[3], corners[2], corners[6], corners[4], corners[5], corners[1]];\n\n        points = points.map(function (p) {\n          var newPos = projector.project(p);\n          newPos.x += posX;\n          newPos.y += posY;\n          return newPos;\n        });\n\n        context.beginPath();\n        context.fillStyle = color;\n        context.moveTo(points[0].x, points[0].y);\n\n        for (var i = 1; i < points.length; i++) {\n          context.lineTo(points[i].x, points[i].y);\n        }\n\n        context.fill();\n      } else {\n        points = corners.slice(0, corners.length);\n        points = points.map(function (p) {\n          var newPos = projector.project(p);\n          newPos.x += posX;\n          newPos.y += posY;\n          return newPos;\n        });\n\n        context.moveTo(points[0].x, points[0].y);\n        context.beginPath();\n        context.strokeStyle = color;\n\n        context.lineTo(points[1].x, points[1].y);\n        context.lineTo(points[3].x, points[3].y);\n        context.lineTo(points[2].x, points[2].y);\n        context.lineTo(points[6].x, points[6].y);\n        context.lineTo(points[4].x, points[4].y);\n        context.lineTo(points[5].x, points[5].y);\n        context.lineTo(points[1].x, points[1].y);\n        context.lineTo(points[0].x, points[0].y);\n        context.lineTo(points[4].x, points[4].y);\n        context.moveTo(points[0].x, points[0].y);\n        context.lineTo(points[2].x, points[2].y);\n        context.moveTo(points[3].x, points[3].y);\n        context.lineTo(points[7].x, points[7].y);\n        context.lineTo(points[6].x, points[6].y);\n        context.moveTo(points[7].x, points[7].y);\n        context.lineTo(points[5].x, points[5].y);\n        context.stroke();\n        context.closePath();\n      }\n    }\n  }, {\n    key: 'top',\n    get: function get() {\n      return this.position.z + this.height;\n    }\n\n    /**\n     * @name Body#frontX\n     * @property {number} right - The front X value of this Body (same as Body.x + Body.widthX)\n     * @readonly\n     */\n\n  }, {\n    key: 'frontX',\n    get: function get() {\n      return this.position.x + this.widthX;\n    }\n\n    /**\n     * @name Body#right\n     * @property {number} right - The front X value of this Body (same as Body.x + Body.widthX) - alias used for QuadTree\n     * @readonly\n     */\n\n  }, {\n    key: 'right',\n    get: function get() {\n      return this.position.x + this.widthX;\n    }\n\n    /**\n     * @name Body#frontY\n     * @property {number} right - The front Y value of this Body (same as Body.y + Body.widthY)\n     * @readonly\n     */\n\n  }, {\n    key: 'frontY',\n    get: function get() {\n      return this.position.y + this.widthY;\n    }\n\n    /**\n     * @name Body#bottom\n     * @property {number} right - The front Y value of this Body (same as Body.y + Body.widthY) - alias used for QuadTree\n     * @readonly\n     */\n\n  }, {\n    key: 'bottom',\n    get: function get() {\n      return this.position.y + this.widthY;\n    }\n\n    /**\n     * @name Body#x\n     * @property {number} x - The x position.\n     */\n\n  }, {\n    key: 'x',\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.position.x = value;\n    }\n\n    /**\n     * @name Body#y\n     * @property {number} y - The y position.\n     */\n\n  }, {\n    key: 'y',\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.position.y = value;\n    }\n\n    /**\n     * @name Body#z\n     * @property {number} z - The z position.\n     */\n\n  }, {\n    key: 'z',\n    get: function get() {\n      return this.position.z;\n    },\n    set: function set(value) {\n      this.position.z = value;\n    }\n  }]);\n\n  return Body;\n}();\n\n/**\n * Render IsoSprite Body Physics Data as text.\n *\n * @method Body#renderBodyInfo\n * @param {Body} body - The Body to render the info of.\n * @param {number} x - X position of the debug info to be rendered.\n * @param {number} y - Y position of the debug info to be rendered.\n * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n */\n// Body.renderBodyInfo = function (debug, body) {\n//\n//     debug.line('x: ' + body.x.toFixed(2), 'y: ' + body.y.toFixed(2), 'z: ' + body.z.toFixed(2), 'widthX: ' + body.widthX, 'widthY: ' + body.widthY, 'height: ' + body.height);\n//     debug.line('velocity x: ' + body.velocity.x.toFixed(2), 'y: ' + body.velocity.y.toFixed(2), 'z: ' + body.velocity.z.toFixed(2), 'deltaX: ' + body._dx.toFixed(2), 'deltaY: ' + body._dy.toFixed(2), 'deltaZ: ' + body._dz.toFixed(2));\n//     debug.line('acceleration x: ' + body.acceleration.x.toFixed(2), 'y: ' + body.acceleration.y.toFixed(2), 'z: ' + body.acceleration.z.toFixed(2), 'speed: ' + body.speed.toFixed(2), 'angle: ' + body.angle.toFixed(2));\n//     debug.line('gravity x: ' + body.gravity.x, 'y: ' + body.gravity.y, 'z: ' + body.gravity.z);\n//     debug.line('bounce x: ' + body.bounce.x.toFixed(2), 'y: ' + body.bounce.y.toFixed(2), 'z: ' + body.bounce.z.toFixed(2));\n//     debug.line('touching: ', 'frontX: ' + (body.touching.frontX ? 1 : 0) + ' frontY: ' + (body.touching.frontY ? 1 : 0) + ' backX: ' + (body.touching.backX ? 1 : 0) + ' backY: ' + (body.touching.backY ? 1 : 0) + ' up: ' + (body.touching.up ? 1 : 0) + ' down: ' + (body.touching.down ? 1 : 0));\n//     debug.line('blocked: ', 'frontX: ' + (body.blocked.frontX ? 1 : 0) + ' frontY: ' + (body.blocked.frontY ? 1 : 0) + ' backX: ' + (body.blocked.backX ? 1 : 0) + ' backY: ' + (body.blocked.backY ? 1 : 0) + ' up: ' + (body.blocked.up ? 1 : 0) + ' down: ' + (body.blocked.down ? 1 : 0));\n//\n// };\n\n// Phaser.Utils.Debug.prototype.body = (function (_super) {\n//\n//     return function (sprite, color, filled, depth) {\n//         if (sprite.body && sprite.body.type === ISOPHYSICS) {\n//             this.start();\n//             Body.render(this.context, sprite.body, color, filled);\n//             if (depth) {\n//                 this.text(sprite.depth.toFixed(2), sprite.x, sprite.y, color, '12px Courier');\n//             }\n//             this.stop();\n//         }\n//\n//         return _super.call(this, sprite, color, filled);\n//     };\n//\n// })(Phaser.Utils.Debug.prototype.body);\n\n// Phaser.Utils.Debug.prototype.bodyInfo = (function (_super) {\n//\n//     return function (sprite, x, y, color) {\n//         if (sprite.body && sprite.body.type === ISOPHYSICS) {\n//             this.start(x, y, color, 210);\n//             Body.renderBodyInfo(this, sprite.body);\n//             this.stop();\n//         }\n//\n//         return _super.call(this, sprite, x, y, color);\n//     };\n//\n// })(Phaser.Utils.Debug.prototype.bodyInfo);\n\n\nexports.default = Body;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/physics/Body.js?");

/***/ }),

/***/ "./src/physics/IsoPhysics.js":
/*!***********************************!*\
  !*** ./src/physics/IsoPhysics.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ../Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _World = __webpack_require__(/*! ./World */ \"./src/physics/World.js\");\n\nvar _World2 = _interopRequireDefault(_World);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * IsoPhysics Physics constructor.\n *\n * @class IsoPhysics\n * @classdesc IsoPhysics Physics\n */\nvar IsoPhysics = function () {\n  /**\n   * @constructor\n   * @param {Phaser.Scene} Reference to the current scene instance.\n   */\n  function IsoPhysics(scene) {\n    _classCallCheck(this, IsoPhysics);\n\n    /**\n     * @property {Phaser.Scene} scene - Local reference to scene.\n     */\n    this.scene = scene;\n\n    /**\n     * @property {Projector} projector - Local reference to the current projector.\n     */\n    var pluginKey = this.scene.sys.settings.map.isoPlugin;\n    this.projector = this.scene[pluginKey].projector;\n\n    /**\n     * @property {World} world - The physics World that gets created on start.\n     */\n    this.world = new _World2.default(this.scene);\n  }\n\n  /**\n   * Find the distance between two display objects (like Sprites).\n   *\n   * @method Isometric.IsoPhysics#distanceBetween\n   * @param {any} source - The Display Object to test from.\n   * @param {any} target - The Display Object to test to.\n   * @return {number} The distance between the source and target objects.\n   */\n\n\n  _createClass(IsoPhysics, [{\n    key: 'distanceBetween',\n    value: function distanceBetween(source, target) {\n      this._dx = source.x - target.x;\n      this._dy = source.y - target.y;\n      this._dz = source.z - target.z;\n\n      return Math.sqrt(this._dx * this._dx + this._dy * this._dy + this._dz * this._dz);\n    }\n\n    /**\n     * Find the distance between a display object (like a Sprite) and the given x/y coordinates only (ignore z).\n     * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\n     * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\n     *\n     * @method IsoPhysics#distanceToXY\n     * @param {any} displayObject - The Display Object to test from.\n     * @param {number} x - The x coordinate to test to.\n     * @param {number} y - The y coordinate to test to.\n     * @return {number} The distance between the object and the x/y coordinates.\n     */\n\n  }, {\n    key: 'distanceToXY',\n    value: function distanceToXY(displayObject, x, y) {\n      this._dx = displayObject.x - x;\n      this._dy = displayObject.y - y;\n\n      return Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n    }\n\n    /**\n     * Find the distance between a display object (like a Sprite) and the given x/y/z coordinates.\n     * The calculation is made from the display objects x/y/z coordinate. This may be the top-left if its anchor hasn't been changed.\n     * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\n     *\n     * @method IsoPhysics#distanceToXYZ\n     * @param {any} displayObjectBody - The Display Object to test from.\n     * @param {number} x - The x coordinate to test to.\n     * @param {number} y - The y coordinate to test to.\n     * @param {number} z - The y coordinate to test to\n     * @return {number} The distance between the object and the x/y coordinates.\n     */\n\n  }, {\n    key: 'distanceToXYZ',\n    value: function distanceToXYZ(displayObjectBody, x, y, z) {\n      this._dx = displayObjectBody.x - x;\n      this._dy = displayObjectBody.y - y;\n      this._dz = displayObjectBody.z - z;\n\n      return Math.sqrt(this._dx * this._dx + this._dy * this._dy + this._dz * this._dz);\n    }\n\n    /**\n     * Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.\n     * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\n     * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\n     * The distance to the Pointer is returned in isometric distance.\n     *\n     * @method IsoPhysics#distanceToPointer\n     * @param {any} displayObjectBody - The Display Object to test from.\n     * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.\n     * @return {number} The distance between the object and the Pointer.\n     */\n\n  }, {\n    key: 'distanceToPointer',\n    value: function distanceToPointer(displayObjectBody, pointer) {\n      pointer = pointer || this.scene.input.activePointer;\n      var isoPointer = this.projector.unproject(pointer.position, undefined, displayObjectBody.z);\n      isoPointer.z = displayObjectBody.z;\n      var a = this.anglesToXYZ(displayObjectBody, isoPointer.x, isoPointer.y, isoPointer.z);\n\n      return a.r;\n    }\n\n    /**\n     * Find the angles in radians between a display object (like a IsoSprite) and the given x/y/z coordinate.\n     *\n     * @method Phaser.Physics.Isometric.Isometric.IsoPhysics#anglesToXYZ\n     * @param {any} displayObjectBody - The Display Object to test from.\n     * @param {number} x - The x coordinate to get the angle to.\n     * @param {number} y - The y coordinate to get the angle to.\n     * @param {number} z - The z coordinate to get the angle to.\n     * @return {number} The angle in radians between displayObjectBody.x/y to Pointer.x/y\n     */\n\n  }, {\n    key: 'anglesToXYZ',\n    value: function anglesToXYZ(displayObjectBody, x, y, z) {\n      // Spherical polar coordinates\n      var r = this.distanceToXYZ(displayObjectBody, x, y, z);\n      var theta = Math.atan2(y - displayObjectBody.y, x - displayObjectBody.x);\n      var phi = Math.acos((z - displayObjectBody.z) / r);\n\n      return { r: r, theta: theta, phi: phi };\n    }\n\n    /**\n     * Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x/y and center into account.\n     * This is not the visual angle but the angle in the isometric co-ordinate system.\n     *\n     * @method Phaser.Physics.Isometric.IsoPhysics#angleToPointer\n     * @param {any} displayObjectBody - The Display Object to test from.\n     * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.\n     * @return {number} The (isometric) angle in radians between displayObjectBody.x/y to Pointer.x/y.\n     */\n\n  }, {\n    key: 'angleToPointer',\n    value: function angleToPointer(displayObjectBody, pointer) {\n      pointer = pointer || this.scene.input.activePointer;\n      var isoPointer = this.projector.unproject(pointer.position, undefined, displayObjectBody.z);\n      isoPointer.z = displayObjectBody.z;\n      var a = this.anglesToXYZ(displayObjectBody, isoPointer.x, isoPointer.y, isoPointer.z);\n\n      return a.theta;\n    }\n\n    /**\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.\n     *\n     * @method Phaser.Physics.IsoPhysics#velocityFromAngle\n     * @param {number} theta - The angle in radians for x,y in the isometric co-ordinate system\n     * @param {number} [phi=Math.PI/2] - The angle in radians for z in the isometric co-ordinate system\n     * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\n     * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated velocity.\n     * @return {Point3} - A Point where point.x contains the velocity x value and so on for y and z.\n     */\n\n  }, {\n    key: 'velocityFromAngles',\n    value: function velocityFromAngles(theta, phi, speed) {\n      if (phi === undefined) {\n        phi = Math.sin(Math.PI / 2);\n      }\n      if (speed === undefined) {\n        speed = 60;\n      }\n\n      return new _Point2.default(Math.cos(theta) * Math.sin(phi) * speed, Math.sin(theta) * Math.sin(phi) * speed, Math.cos(phi) * speed);\n    }\n\n    /**\n     * Sets the acceleration.x/y property on the display object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)\n     * You must give a maximum speed value, beyond which the display object won't go any faster.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Isometric.IsoPhysics#accelerateToXYZ\n     * @param {any} displayObject - The display object to move.\n     * @param {number} x - The x coordinate to accelerate towards.\n     * @param {number} y - The y coordinate to accelerate towards.\n     * @param {number} z - The z coordinate to accelerate towards.\n     * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.\n     * @param {number} [zSpeedMax=500] - The maximum z velocity the display object can reach.\n     * @return {number} The angle (in radians).\n     */\n\n  }, {\n    key: 'accelerateToXYZ',\n    value: function accelerateToXYZ(displayObject, x, y, z, speed, xSpeedMax, ySpeedMax, zSpeedMax) {\n      if (speed === undefined) {\n        speed = 60;\n      }\n      if (xSpeedMax === undefined) {\n        xSpeedMax = 500;\n      }\n      if (ySpeedMax === undefined) {\n        ySpeedMax = 500;\n      }\n      if (zSpeedMax === undefined) {\n        zSpeedMax = 500;\n      }\n\n      var a = this.anglesToXYZ(displayObject.body, x, y, z);\n      var v = this.velocityFromAngles(a.theta, a.phi, speed);\n\n      displayObject.body.acceleration.setTo(v.x, v.y, v.z);\n      displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax, zSpeedMax);\n\n      return a.theta;\n    }\n\n    /**\n     * Move the given display object towards the x/y coordinates at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Isometric.IsoPhysics#moveToXYZ\n     * @param {any} displayObject - The display object to move, must have an isoArcade body.\n     * @param {number} x - The x coordinate to move towards.\n     * @param {number} y - The y coordinate to move towards.\n     * @param {number} z - The z coordinate to move towards.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     * @return {number} The angle (in radians).\n     */\n\n  }, {\n    key: 'moveToXYZ',\n    value: function moveToXYZ(displayObject, x, y, z, speed, maxTime) {\n      if (typeof speed === 'undefined') {\n        speed = 60;\n      }\n      if (typeof maxTime === 'undefined') {\n        maxTime = 0;\n      }\n\n      if (maxTime > 0) {\n        //  We know how many pixels we need to move, but how fast?\n        speed = this.distanceToXYZ(displayObject.body, x, y, z) / (maxTime / 1000);\n      }\n      var a = this.anglesToXYZ(displayObject.body, x, y, z);\n      var v = this.velocityFromAngles(a.theta, a.phi, speed);\n\n      displayObject.body.velocity.copyFrom(v);\n\n      return a.theta;\n    }\n\n    /**\n     * Move the given display object towards the destination object at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Isometric.IsoPhysics#moveToObject\n     * @param {any} displayObject - The display object to move.\n     * @param {any} destination - The display object to move towards. Can be any object but must have visible x/y/z properties.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     * @return {number} The angle (in radians).\n     */\n\n  }, {\n    key: 'moveToObject',\n    value: function moveToObject(displayObject, destination, speed, maxTime) {\n      return this.moveToXYZ(displayObject, destination.x, destination.y, destination.z, speed, maxTime);\n    }\n\n    /**\n     * Move the given display object towards the pointer at a steady x & y velocity. If no pointer is given it will use Phaser.Input.activePointer.\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Isometric.IsoPhysics#moveToPointer\n     * @param {any} displayObject - The display object to move.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {Phaser.Pointer} [pointer] - The pointer to move towards. Defaults to Phaser.Input.activePointer.\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     * @return {number} The angle (in radians).\n     */\n\n  }, {\n    key: 'moveToPointer',\n    value: function moveToPointer(displayObject, speed, pointer, maxTime) {\n      pointer = pointer || this.game.input.activePointer;\n      var isoPointer = this.game.iso.unproject(pointer.position, undefined, displayObject.body.z);\n      isoPointer.z = displayObject.body.z;\n\n      if (typeof speed === 'undefined') {\n        speed = 60;\n      }\n      if (typeof maxTime === 'undefined') {\n        maxTime = 0;\n      }\n\n      if (maxTime > 0) {\n        //  We know how many pixels we need to move, but how fast?\n        speed = this.distanceToXYZ(displayObject.body, isoPointer.x, isoPointer.y, isoPointer.z) / (maxTime / 1000);\n      }\n      var a = this.anglesToXYZ(displayObject.body, isoPointer.x, isoPointer.y, isoPointer.z);\n      var v = this.velocityFromAngles(a.theta, a.phi, speed);\n\n      displayObject.body.velocity.x = v.x;\n      displayObject.body.velocity.y = v.y;\n\n      return a.theta;\n    }\n  }, {\n    key: 'boot',\n    value: function boot() {\n      var eventEmitter = this.scene.sys.events;\n\n      eventEmitter.on('update', this.world.update, this.world);\n      eventEmitter.on('postupdate', this.world.postUpdate, this.world);\n    }\n  }], [{\n    key: 'register',\n    value: function register(PluginManager) {\n      PluginManager.register('IsoPhysics', IsoPhysics, 'isoPhysics');\n    }\n  }]);\n\n  return IsoPhysics;\n}();\n\n//\n// Phaser.Physics.prototype.parseConfig = (function (_super) {\n//\n//     return function () {\n//         if (this.config.hasOwnProperty('isoArcade') && this.config['isoArcade'] === true && hasOwnProperty('IsoPhysics')) {\n//             this.isoArcade = new Phaser.Plugin.Isometric(this.game, this.config);\n//         }\n//         return _super.call(this);\n//     };\n//\n// })(Phaser.Physics.prototype.parseConfig);\n//\n// Phaser.Physics.prototype.startSystem = (function (_super) {\n//\n//     return function (system) {\n//         if (system === ISOARCADE && this.isoArcade === null) {\n//             this.isoArcade = new IsoPhysics(this.game);\n//             this.setBoundsToWorld();\n//         }\n//         return _super.call(this, system);\n//     };\n//\n// })(Phaser.Physics.prototype.startSystem);\n//\n// Phaser.Physics.prototype.enable = (function (_super) {\n//\n//     return function (sprite, system) {\n//         if (system === ISOARCADE && this.isoArcade) {\n//             this.isoArcade.enable(sprite);\n//         }\n//         return _super.call(this, sprite, system);\n//     };\n//\n// })(Phaser.Physics.prototype.enable);\n//\n// Phaser.Physics.prototype.setBoundsToWorld = (function (_super) {\n//\n//     return function () {\n//         if (this.isoArcade) {\n//             this.isoArcade.setBoundsToWorld();\n//         }\n//         return _super.call(this);\n//     };\n//\n// })(Phaser.Physics.prototype.setBoundsToWorld);\n//\n// Phaser.Physics.prototype.destroy = (function (_super) {\n//\n//     return function () {\n//         this.isoArcade = null;\n//\n//         return _super.call(this);\n//     };\n//\n// })(Phaser.Physics.prototype.destroy);\n\n\nexports.default = IsoPhysics;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/physics/IsoPhysics.js?");

/***/ }),

/***/ "./src/physics/World.js":
/*!******************************!*\
  !*** ./src/physics/World.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Body = __webpack_require__(/*! ./Body */ \"./src/physics/Body.js\");\n\nvar _Body2 = _interopRequireDefault(_Body);\n\nvar _Point = __webpack_require__(/*! ../Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Cube = __webpack_require__(/*! ../Cube */ \"./src/Cube.js\");\n\nvar _Cube2 = _interopRequireDefault(_Cube);\n\nvar _Octree = __webpack_require__(/*! ../Octree */ \"./src/Octree.js\");\n\nvar _Octree2 = _interopRequireDefault(_Octree);\n\nvar _IsoSprite = __webpack_require__(/*! ../IsoSprite */ \"./src/IsoSprite.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _Phaser = Phaser,\n    GameObjects = _Phaser.GameObjects,\n    Structs = _Phaser.Structs;\n\nvar World = function () {\n  function World(scene) {\n    _classCallCheck(this, World);\n\n    /**\n     * Bodies\n     *\n     * @name World#bodies\n     * @type {Phaser.Structs.Set.<Body>}\n     * @since 3.0.0\n     */\n    this.bodies = new Structs.Set();\n\n    /**\n     * @property {Cube} bounds - The bounds inside of which the physics world exists. Defaults to match the world bounds relatively closely given the isometric projection.\n     */\n    var _scene$sys$game$confi = scene.sys.game.config,\n        width = _scene$sys$game$confi.width,\n        height = _scene$sys$game$confi.height;\n\n    this.bounds = new _Cube2.default(0, 0, 0, width * 0.5, width * 0.5, height);\n\n    /**\n     * @property {Point3} gravity - The World gravity setting. Defaults to x: 0, y: 0, z: 0 or no gravity.\n     */\n    this.gravity = new _Point2.default();\n\n    /**\n     * Set the checkCollision properties to control for which bounds collision is processed.\n     * For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.\n     * @property {object} checkCollision - An object containing allowed collision flags.\n     */\n    this.checkCollision = {\n      up: true,\n      down: true,\n      frontX: true,\n      frontY: true,\n      backX: true,\n      backY: true\n    };\n\n    /**\n     * @property {number} OVERLAP_BIAS - A value added to the delta values during collision checks.\n     */\n    this.OVERLAP_BIAS = 4;\n\n    /**\n     * @property {boolean} forceX - If true World.separate will always separate on the X and Y axes before Z. Otherwise it will check gravity totals first.\n     */\n    this.forceXY = false;\n\n    /**\n     * @property {boolean} skipTree - If true an Octree will never be used for any collision. Handy for tightly packed games. See also Body.skipTree.\n     */\n    this.skipTree = false;\n\n    /**\n     * @property {number} maxObjects - Used by the Octree to set the maximum number of objects per quad.\n     */\n    this.maxObjects = 10;\n\n    /**\n     * @property {number} maxLevels - Used by the Octree to set the maximum number of iteration levels.\n     */\n    this.maxLevels = 4;\n\n    /**\n     * @property {Octree} octree - The world Octree.\n     */\n    this.octree = new _Octree2.default(this.bounds.x, this.bounds.y, this.bounds.z, this.bounds.widthX, this.bounds.widthY, this.bounds.height, this.maxObjects, this.maxLevels);\n\n    //  Avoid gc spikes by caching these values for re-use\n\n    /**\n     * @property {number} _overlap - Internal cache var.\n     * @private\n     */\n    this._overlap = 0;\n\n    /**\n     * @property {number} _maxOverlap - Internal cache var.\n     * @private\n     */\n    this._maxOverlap = 0;\n\n    /**\n     * @property {number} _velocity1 - Internal cache var.\n     * @private\n     */\n    this._velocity1 = 0;\n\n    /**\n     * @property {number} _velocity2 - Internal cache var.\n     * @private\n     */\n    this._velocity2 = 0;\n\n    /**\n     * @property {number} _newVelocity1 - Internal cache var.\n     * @private\n     */\n    this._newVelocity1 = 0;\n\n    /**\n     * @property {number} _newVelocity2 - Internal cache var.\n     * @private\n     */\n    this._newVelocity2 = 0;\n\n    /**\n     * @property {number} _average - Internal cache var.\n     * @private\n     */\n    this._average = 0;\n\n    /**\n     * @property {Array} _mapData - Internal cache var.\n     * @private\n     */\n    this._mapData = [];\n\n    /**\n     * @property {boolean} _result - Internal cache var.\n     * @private\n     */\n    this._result = false;\n\n    /**\n     * @property {number} _total - Internal cache var.\n     * @private\n     */\n    this._total = 0;\n\n    /**\n     * @property {number} _angle - Internal cache var.\n     * @private\n     */\n    this._angle = 0;\n\n    /**\n     * @property {number} _dx - Internal cache var.\n     * @private\n     */\n    this._dx = 0;\n\n    /**\n     * @property {number} _dy - Internal cache var.\n     * @private\n     */\n    this._dy = 0;\n\n    /**\n     * @property {number} _dz - Internal cache var.\n     * @private\n     */\n    this._dz = 0;\n  }\n\n  /**\n   * This will create an IsoPhysics Physics body on the given game object or array of game objects.\n   * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n   *\n   * @method IsoPhysics#enable\n   * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n   * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n   */\n\n\n  _createClass(World, [{\n    key: 'enable',\n    value: function enable(object) {\n      var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var i = 1;\n\n      if (Array.isArray(object)) {\n        i = object.length;\n\n        while (i--) {\n          if (object[i] instanceof GameObjects.Group) {\n            //  If it's a Group then we do it on the children regardless\n            this.enable(object[i].children, children);\n          } else {\n            this.enableBody(object[i]);\n\n            if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0) {\n              this.enable(object[i], true);\n            }\n          }\n        }\n      } else if (object instanceof GameObjects.Group) {\n        //  If it's a Group then we do it on the children regardless\n        this.enable(object.children, children);\n      } else {\n        this.enableBody(object);\n\n        if (children && object.hasOwnProperty('children') && object.children.length > 0) {\n          this.enable(object.children, true);\n        }\n      }\n    }\n\n    /**\n     * Creates an IsoPhysics Physics body on the given game object.\n     * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\n     *\n     * @method IsoPhysics#enableBody\n     * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.\n     */\n\n  }, {\n    key: 'enableBody',\n    value: function enableBody(object) {\n      if (object.body === null) {\n        object.body = new _Body2.default(object);\n        this.bodies.set(object.body);\n      }\n\n      return object;\n    }\n\n    /**\n     * Updates the size of this physics world.\n     *\n     * @method IsoPhysics#setBounds\n     * @param {number} x - Bottom rear most corner of the world.\n     * @param {number} y - Bottom rear most corner of the world.\n     * @param {number} z - Bottom rear most corner of the world.\n     * @param {number} widthX - New X width (breadth) of the world. Can never be smaller than the Game.width.\n     * @param {number} widthY - New Y width (depth) of the world. Can never be smaller than the Game.width.\n     * @param {number} height - New height of the world. Can never be smaller than the Game.height.\n     */\n\n  }, {\n    key: 'setBounds',\n    value: function setBounds(x, y, z, widthX, widthY, height) {\n      this.bounds.setTo(x, y, z, widthX, widthY, height);\n    }\n\n    /**\n     * Updates the size of this physics world to match the size of the game world.\n     *\n     * @method IsoPhysics#setBoundsToWorld\n     */\n\n  }, {\n    key: 'setBoundsToWorld',\n    value: function setBoundsToWorld() {\n      var _scene$sys$game$confi2 = this.scene.sys.game.config,\n          width = _scene$sys$game$confi2.width,\n          height = _scene$sys$game$confi2.height;\n\n      this.bounds.setTo(0, 0, 0, width * 0.5, width * 0.5, height);\n    }\n\n    /**\n     * A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.\n     * Based on a function in Flixel by @ADAMATOMIC\n     *\n     * @method World#computeVelocity\n     * @param {number} axis - 0 for nothing, 1 for X-axis, 2 for Y-axis, 3 for vertical (Z-axis).\n     * @param {Body} body - The Body object to be updated.\n     * @param {number} velocity - Any component of velocity (e.g. 20).\n     * @param {number} acceleration - Rate at which the velocity is changing.\n     * @param {number} drag - Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.\n     * @param {number} [max=10000] - An absolute value cap for the velocity.\n     * @return {number} The altered Velocity value.\n     */\n\n  }, {\n    key: 'computeVelocity',\n    value: function computeVelocity(axis, body, velocity, acceleration, drag, max, delta) {\n      max = max || 10000;\n\n      if (axis === 1 && body.allowGravity) {\n        velocity += (this.gravity.x + body.gravity.x) * delta;\n      } else if (axis === 2 && body.allowGravity) {\n        velocity += (this.gravity.y + body.gravity.y) * delta;\n      } else if (axis === 3 && body.allowGravity) {\n        velocity += (this.gravity.z + body.gravity.z) * delta;\n      }\n\n      if (acceleration) {\n        velocity += acceleration * delta;\n      } else if (drag) {\n        this._drag = drag * delta;\n\n        if (velocity - this._drag > 0) {\n          velocity -= this._drag;\n        } else if (velocity + this._drag < 0) {\n          velocity += this._drag;\n        } else {\n          velocity = 0;\n        }\n      }\n\n      if (velocity > max) {\n        velocity = max;\n      } else if (velocity < -max) {\n        velocity = -max;\n      }\n\n      return velocity;\n    }\n\n    /**\n     * The core separation function to separate two physics bodies.\n     *\n     * @private\n     * @method IsoPhysics#separate\n     * @param {Body} body1 - The first Body object to separate.\n     * @param {Body} body2 - The second Body object to separate.\n     * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this function is set then the sprites will only be collided if it returns true.\n     * @param {object} [callbackContext] - The context in which to run the process callback.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     * @return {boolean} Returns true if the bodies collided, otherwise false.\n     */\n\n  }, {\n    key: 'separate',\n    value: function separate(body1, body2, processCallback, callbackContext, overlapOnly) {\n      if (!body1.enable || !body2.enable || !this.intersects(body1, body2)) {\n        return false;\n      }\n\n      //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\n      if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) {\n        return false;\n      }\n\n      if (overlapOnly) {\n        //  We already know they intersect from the check above, and we don't need separation, so ...\n        return true;\n      }\n\n      //  Do we separate on X and Y first?\n      //  If we weren't having to carry around so much legacy baggage with us, we could do this properly. But alas ...\n      if (this.forceXY || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.x + body1.gravity.x) || Math.abs(this.gravity.z + body1.gravity.z) < Math.abs(this.gravity.y + body1.gravity.y)) {\n        this._result = this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly) || this.separateZ(body1, body2, overlapOnly);\n      } else {\n        this._result = this.separateZ(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly);\n      }\n\n      return this._result;\n    }\n\n    /**\n     * Check for intersection against two bodies.\n     *\n     * @method IsoPhysics#intersects\n     * @param {Body} body1 - The Body object to check.\n     * @param {Body} body2 - The Body object to check.\n     * @return {boolean} True if they intersect, otherwise false.\n     */\n\n  }, {\n    key: 'intersects',\n    value: function intersects(body1, body2) {\n      if (body1.frontX <= body2.x) {\n        return false;\n      }\n\n      if (body1.frontY <= body2.y) {\n        return false;\n      }\n\n      if (body1.x >= body2.frontX) {\n        return false;\n      }\n\n      if (body1.y >= body2.frontY) {\n        return false;\n      }\n\n      if (body1.top <= body2.z) {\n        return false;\n      }\n\n      if (body1.z >= body2.top) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * The core separation function to separate two physics bodies on the x axis.\n     *\n     * @private\n     * @method IsoPhysics#separateX\n     * @param {Body} body1 - The Body object to separate.\n     * @param {Body} body2 - The Body object to separate.\n     * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.\n     * @return {boolean} Returns true if the bodies were separated, otherwise false.\n     */\n\n  }, {\n    key: 'separateX',\n    value: function separateX(body1, body2, overlapOnly) {\n      //  Can't separate two immovable bodies\n      if (body1.immovable && body2.immovable) {\n        return false;\n      }\n\n      this._overlap = 0;\n\n      this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;\n\n      if (body1.deltaX() === 0 && body2.deltaX() === 0) {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n      } else if (body1.deltaX() > body2.deltaX()) {\n        //  Body1 is moving forward and/or Body2 is moving back\n        this._overlap = body1.frontX - body2.x;\n\n        if (this._overlap > this._maxOverlap || body1.checkCollision.frontX === false || body2.checkCollision.backX === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.frontX = true;\n          body2.touching.none = false;\n          body2.touching.backX = true;\n        }\n      } else if (body1.deltaX() < body2.deltaX()) {\n        //  Body1 is moving back and/or Body2 is moving forward\n        this._overlap = body1.x - body2.widthX - body2.x;\n\n        if (-this._overlap > this._maxOverlap || body1.checkCollision.backX === false || body2.checkCollision.frontX === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.backX = true;\n          body2.touching.none = false;\n          body2.touching.frontX = true;\n        }\n      }\n\n      //  Then adjust their positions and velocities accordingly (if there was any overlap)\n      if (this._overlap !== 0) {\n        body1.overlapX = this._overlap;\n        body2.overlapX = this._overlap;\n\n        if (overlapOnly || body1.customSeparateX || body2.customSeparateX) {\n          return true;\n        }\n\n        this._velocity1 = body1.velocity.x;\n        this._velocity2 = body2.velocity.x;\n\n        if (!body1.immovable && !body2.immovable) {\n          this._overlap *= 0.5;\n\n          body1.x = body1.x - this._overlap;\n          body2.x += this._overlap;\n\n          this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);\n          this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);\n          this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\n          this._newVelocity1 -= this._average;\n          this._newVelocity2 -= this._average;\n\n          body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;\n          body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;\n        } else if (!body1.immovable) {\n          body1.x = body1.x - this._overlap;\n          body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;\n        } else if (!body2.immovable) {\n          body2.x += this._overlap;\n          body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * The core separation function to separate two physics bodies on the x axis.\n     *\n     * @private\n     * @method IsoPhysics#separateY\n     * @param {Body} body1 - The Body object to separate.\n     * @param {Body} body2 - The Body object to separate.\n     * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.\n     * @return {boolean} Returns true if the bodies were separated, otherwise false.\n     */\n\n  }, {\n    key: 'separateY',\n    value: function separateY(body1, body2, overlapOnly) {\n      //  Can't separate two immovable bodies\n      if (body1.immovable && body2.immovable) {\n        return false;\n      }\n\n      this._overlap = 0;\n\n      this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;\n\n      if (body1.deltaY() === 0 && body2.deltaY() === 0) {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n      } else if (body1.deltaY() > body2.deltaY()) {\n        //  Body1 is moving forward and/or Body2 is moving back\n        this._overlap = body1.frontY - body2.y;\n\n        if (this._overlap > this._maxOverlap || body1.checkCollision.frontY === false || body2.checkCollision.backY === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.frontY = true;\n          body2.touching.none = false;\n          body2.touching.backY = true;\n        }\n      } else if (body1.deltaY() < body2.deltaY()) {\n        //  Body1 is moving back and/or Body2 is moving forward\n        this._overlap = body1.y - body2.widthY - body2.y;\n\n        if (-this._overlap > this._maxOverlap || body1.checkCollision.backY === false || body2.checkCollision.frontY === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.backY = true;\n          body2.touching.none = false;\n          body2.touching.frontY = true;\n        }\n      }\n\n      //  Then adjust their positions and velocities accordingly (if there was any overlap)\n      if (this._overlap !== 0) {\n        body1.overlapY = this._overlap;\n        body2.overlapY = this._overlap;\n\n        if (overlapOnly || body1.customSeparateY || body2.customSeparateY) {\n          return true;\n        }\n\n        this._velocity1 = body1.velocity.y;\n        this._velocity2 = body2.velocity.y;\n\n        if (!body1.immovable && !body2.immovable) {\n          this._overlap *= 0.5;\n\n          body1.y = body1.y - this._overlap;\n          body2.y += this._overlap;\n\n          this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);\n          this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);\n          this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\n          this._newVelocity1 -= this._average;\n          this._newVelocity2 -= this._average;\n\n          body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;\n          body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;\n        } else if (!body1.immovable) {\n          body1.y = body1.y - this._overlap;\n          body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;\n        } else if (!body2.immovable) {\n          body2.y += this._overlap;\n          body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * The core separation function to separate two physics bodies on the z axis.\n     *\n     * @private\n     * @method IsoPhysics#separateZ\n     * @param {Body} body1 - The Body object to separate.\n     * @param {Body} body2 - The Body object to separate.\n     * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.\n     * @return {boolean} Returns true if the bodies were separated, otherwise false.\n     */\n\n  }, {\n    key: 'separateZ',\n    value: function separateZ(body1, body2, overlapOnly) {\n      //  Can't separate two immovable or non-existing bodys\n      if (body1.immovable && body2.immovable) {\n        return false;\n      }\n\n      this._overlap = 0;\n\n      this._maxOverlap = body1.deltaAbsZ() + body2.deltaAbsZ() + this.OVERLAP_BIAS;\n\n      if (body1.deltaZ() === 0 && body2.deltaZ() === 0) {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n      } else if (body1.deltaZ() > body2.deltaZ()) {\n        //  Body1 is moving down and/or Body2 is moving up\n        this._overlap = body1.top - body2.z;\n\n        if (this._overlap > this._maxOverlap || body1.checkCollision.down === false || body2.checkCollision.up === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.down = true;\n          body2.touching.none = false;\n          body2.touching.up = true;\n        }\n      } else if (body1.deltaZ() < body2.deltaZ()) {\n        //  Body1 is moving up and/or Body2 is moving down\n        this._overlap = body1.z - body2.top;\n\n        if (-this._overlap > this._maxOverlap || body1.checkCollision.up === false || body2.checkCollision.down === false) {\n          this._overlap = 0;\n        } else {\n          body1.touching.none = false;\n          body1.touching.up = true;\n          body2.touching.none = false;\n          body2.touching.down = true;\n        }\n      }\n\n      //  Then adjust their positions and velocities accordingly (if there was any overlap)\n      if (this._overlap !== 0) {\n        body1.overlapZ = this._overlap;\n        body2.overlapZ = this._overlap;\n\n        if (overlapOnly || body1.customSeparateY || body2.customSeparateZ) {\n          return true;\n        }\n\n        this._velocity1 = body1.velocity.z;\n        this._velocity2 = body2.velocity.z;\n\n        if (!body1.immovable && !body2.immovable) {\n          this._overlap *= 0.5;\n\n          body1.z = body1.z - this._overlap;\n          body2.z += this._overlap;\n\n          this._newVelocity1 = Math.sqrt(this._velocity2 * this._velocity2 * body2.mass / body1.mass) * (this._velocity2 > 0 ? 1 : -1);\n          this._newVelocity2 = Math.sqrt(this._velocity1 * this._velocity1 * body1.mass / body2.mass) * (this._velocity1 > 0 ? 1 : -1);\n          this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\n          this._newVelocity1 -= this._average;\n          this._newVelocity2 -= this._average;\n\n          body1.velocity.z = this._average + this._newVelocity1 * body1.bounce.z;\n          body2.velocity.z = this._average + this._newVelocity2 * body2.bounce.z;\n        } else if (!body1.immovable) {\n          body1.z = body1.z - this._overlap;\n          body1.velocity.z = this._velocity2 - this._velocity1 * body1.bounce.z;\n\n          //  This is special case code that handles things like moving platforms you can ride\n          if (body2.moves) {\n            body1.x += body2.x - body2.prev.x;\n            body1.y += body2.y - body2.prev.y;\n          }\n        } else if (!body2.immovable) {\n          body2.z += this._overlap;\n          body2.velocity.z = this._velocity1 - this._velocity2 * body2.bounce.z;\n\n          //  This is special case code that handles things like moving platforms you can ride\n          if (body1.moves) {\n            body2.x += body1.x - body1.prev.x;\n            body2.y += body1.y - body1.prev.y;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks for overlaps between two game objects. The objects can be IsoSprites or Groups.\n     * You can perform IsoSprite vs. IsoSprite, IsoSprite vs. Group and Group vs. Group overlap checks.\n     * Unlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\n     * The second parameter can be an array of objects, of differing types.\n     * NOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups within Groups).\n     *\n     * @method IsoPhysics#overlap\n     * @param {IsoSprite|Phaser.Group} object1 - The first object to check. Can be an instance of IsoSprite or Phaser.Group.\n     * @param {IsoSprite|Phaser.Group|array} object2 - The second object or array of objects to check. Can be IsoSprite or Phaser.Group.\n     * @param {function} [overlapCallback=null] - An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then overlapCallback will only be called if processCallback returns true.\n     * @param {object} [callbackContext] - The context in which to run the callbacks.\n     * @return {boolean} True if an overlap occured otherwise false.\n     */\n\n  }, {\n    key: 'overlap',\n    value: function overlap(object1, object2) {\n      var overlapCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var processCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var callbackContext = arguments[4];\n\n      callbackContext = callbackContext || overlapCallback;\n\n      this._result = false;\n      this._total = 0;\n\n      if (Array.isArray(object2)) {\n        for (var i = 0, len = object2.length; i < len; i++) {\n          this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);\n        }\n      } else {\n        this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);\n      }\n\n      return this._total > 0;\n    }\n\n    /**\n     * Checks for collision between two game objects. You can perform IsoSprite vs. IsoSprite, IsoSprite vs. Group or Group vs. Group collisions.\n     * The second parameter can be an array of objects, of differing types.\n     * The objects are also automatically separated. If you don't require separation then use IsoPhysics.overlap instead.\n     * An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\n     * giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\n     * The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.\n     * NOTE: This function is not recursive, and will not test against children of objects passed (i.e. Groups within Groups).\n     *\n     * @method IsoPhysics#collide\n     * @param {IsoSprite|Phaser.Group} object1 - The first object to check. Can be an instance of IsoSprite or Phaser.Group.\n     * @param {IsoSprite|Phaser.Group|array} object2 - The second object or array of objects to check. Can be IsoSprite or Phaser.Group.\n     * @param {function} [collideCallback=null] - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are colliding Group vs. Sprite, in which case Sprite will always be the first parameter.\n     * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} [callbackContext] - The context in which to run the callbacks.\n     * @return {boolean} True if a collision occured otherwise false.\n     */\n\n  }, {\n    key: 'collide',\n    value: function collide(object1, object2) {\n      var collideCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var processCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var callbackContext = arguments[4];\n\n      callbackContext = callbackContext || collideCallback;\n\n      this._result = false;\n      this._total = 0;\n\n      if (Array.isArray(object2)) {\n        for (var i = 0, len = object2.length; i < len; i++) {\n          this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);\n        }\n      } else {\n        this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);\n      }\n\n      return this._total > 0;\n    }\n\n    /**\n     * Internal collision handler.\n     *\n     * @method IsoPhysics#collideHandler\n     * @private\n     * @param {IsoSprite|Phaser.Group} object1 - The first object to check. Can be an instance of IsoSprite or Phaser.Group.\n     * @param {IsoSprite|Phaser.Group} object2 - The second object to check. Can be an instance of IsoSprite or Phaser.Group. Can also be an array of objects to check.\n     * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     */\n\n  }, {\n    key: 'collideHandler',\n    value: function collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n      //  Only collide valid objects\n      if (!object2 && object1.type === Phaser.GROUP) {\n        this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);\n        return;\n      }\n\n      if (object1 && object2) {\n        //  ISOSPRITES\n        if (object1.type === _IsoSprite.ISOSPRITE) {\n          if (object2.type === _IsoSprite.ISOSPRITE) {\n            this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n          } else if (object2.type === Phaser.GROUP) {\n            this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n        //  GROUPS\n        else if (object1.type === Phaser.GROUP) {\n            if (object2.type === _IsoSprite.ISOSPRITE) {\n              this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n            } else if (object2.type === Phaser.GROUP) {\n              this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n            }\n          }\n      }\n    }\n\n    /**\n     * An internal function. Use IsoPhysics.collide instead.\n     *\n     * @method IsoPhysics#collideSpriteVsSprite\n     * @private\n     * @param {IsoSprite} sprite1 - The first sprite to check.\n     * @param {IsoSprite} sprite2 - The second sprite to check.\n     * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     * @return {boolean} True if there was a collision, otherwise false.\n     */\n\n  }, {\n    key: 'collideSpriteVsSprite',\n    value: function collideSpriteVsSprite(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n      if (!sprite1.body || !sprite2.body) {\n        return false;\n      }\n\n      if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\n        if (collideCallback) {\n          collideCallback.call(callbackContext, sprite1, sprite2);\n        }\n\n        this._total++;\n      }\n\n      return true;\n    }\n\n    /**\n     * An internal function. Use IsoPhysics.collide instead.\n     *\n     * @method IsoPhysics#collideSpriteVsGroup\n     * @private\n     * @param {IsoSprite} sprite - The sprite to check.\n     * @param {Phaser.Group} group - The Group to check.\n     * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     */\n\n  }, {\n    key: 'collideSpriteVsGroup',\n    value: function collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n      var i, len;\n\n      if (group.children.size === 0 || !sprite.body) {\n        return;\n      }\n\n      if (sprite.body.skipTree || this.skipTree) {\n        for (i = 0, len = group.children.size; i < len; i++) {\n          var child = group.children.entries[i];\n          if (child) {\n            this.collideSpriteVsSprite(sprite, child, collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n      } else {\n        //  What is the sprite colliding with in the octree?\n        this.octree.clear();\n\n        this.octree.reset(this.bounds.x, this.bounds.y, this.bounds.z, this.bounds.widthX, this.bounds.widthY, this.bounds.height, this.maxObjects, this.maxLevels);\n\n        this.octree.populate(group);\n\n        this._potentials = this.octree.retrieve(sprite);\n\n        for (i = 0, len = this._potentials.length; i < len; i++) {\n          //  We have our potential suspects, are they in this group?\n          if (this.separate(sprite.body, this._potentials[i], processCallback, callbackContext, overlapOnly)) {\n            if (collideCallback) {\n              collideCallback.call(callbackContext, sprite, this._potentials[i].sprite);\n            }\n\n            this._total++;\n          }\n        }\n      }\n    }\n\n    /**\n     * An internal function. Use IsoPhysics.collide instead.\n     *\n     * @method IsoPhysics#collideGroupVsSelf\n     * @private\n     * @param {Phaser.Group} group - The Group to check.\n     * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     * @return {boolean} True if there was a collision, otherwise false.\n     */\n\n  }, {\n    key: 'collideGroupVsSelf',\n    value: function collideGroupVsSelf(group, collideCallback, processCallback, callbackContext, overlapOnly) {\n      if (group.children.size === 0) {\n        return;\n      }\n\n      var len = group.children.size;\n\n      for (var i = 0; i < len; i++) {\n        for (var j = i + 1; j <= len; j++) {\n          var entries = group.children.entries;\n          var spriteOne = entries[i];\n          var spriteTwo = entries[j];\n\n          if (spriteOne && spriteTwo) {\n            this.collideSpriteVsSprite(spriteOne, spriteTwo, collideCallback, processCallback, callbackContext, overlapOnly);\n          }\n        }\n      }\n    }\n\n    /**\n     * An internal function. Use IsoPhysics.collide instead.\n     *\n     * @method IsoPhysics#collideGroupVsGroup\n     * @private\n     * @param {Phaser.Group} group1 - The first Group to check.\n     * @param {Phaser.Group} group2 - The second Group to check.\n     * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n     * @param {object} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n     */\n\n  }, {\n    key: 'collideGroupVsGroup',\n    value: function collideGroupVsGroup(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n      if (group1.children.size === 0 || group2.children.size === 0) {\n        return;\n      }\n\n      for (var i = 0, len = group1.children.size; i < len; i++) {\n        this.collideSpriteVsGroup(group1.children.entries[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\n      }\n    }\n\n    /**\n     * Called automatically by a Physics body, it updates all motion related values on the Body.\n     *\n     * @method IsoPhysics#updateMotion\n     * @param {Body} body - The Body object to be updated.\n     */\n\n  }, {\n    key: 'updateMotion',\n    value: function updateMotion(body, delta) {\n      this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity;\n      body.angularVelocity += this._velocityDelta;\n      body.rotation += body.angularVelocity * delta;\n\n      body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x, delta);\n      body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y, delta);\n      body.velocity.z = this.computeVelocity(3, body, body.velocity.z, body.acceleration.z, body.drag.z, body.maxVelocity.z, delta);\n    }\n  }, {\n    key: 'update',\n    value: function update(time, delta) {\n      var bodies = this.bodies.entries;\n      var len = bodies.length;\n      var i = void 0;\n\n      for (i = 0; i < len; i++) {\n        var body = bodies[i];\n        if (body.enable) {\n          bodies[i].update(time, delta);\n        }\n      }\n    }\n  }, {\n    key: 'postUpdate',\n    value: function postUpdate() {\n      var bodies = this.bodies.entries;\n      var len = bodies.length;\n      var i = void 0;\n\n      for (i = 0; i < len; i++) {\n        var body = bodies[i];\n        if (body.enable) {\n          body.postUpdate();\n        }\n      }\n    }\n  }]);\n\n  return World;\n}();\n\nexports.default = World;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/physics/World.js?");

/***/ }),

/***/ 0:
/*!********************************!*\
  !*** multi ./src/IsoPlugin.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/IsoPlugin.js */\"./src/IsoPlugin.js\");\n\n\n//# sourceURL=webpack://phaser-plugin-isometric/multi_./src/IsoPlugin.js?");

/***/ })

/******/ });